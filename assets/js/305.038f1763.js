(window.webpackJsonp=window.webpackJsonp||[]).push([[305],{631:function(v,_,t){"use strict";t.r(_);var e=t(4),o=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"什么是堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是堆"}},[v._v("#")]),v._v(" 什么是堆")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("讲义概念")]),v._v(" "),_("p",[_("code",[v._v("优先队列")]),_("strong",[v._v("（Priority Queue）")]),v._v("：特殊的“"),_("code",[v._v("队列")]),v._v("”，取出元素的顺序是依照元素的"),_("code",[v._v("优先权（关键字）")]),v._v("大小，而不是元素进入队列的先后顺序。")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("GPT概念")]),v._v(" "),_("p",[v._v("堆是一种特殊的数据结构，常用于实现优先队列。在计算机科学中，堆是一个近似完全二叉树的数组对象，这个二叉树除了最后一个层级外，每个层级都是完全填充的，并且所有的节点都尽可能地集中在左侧。堆的主要特点是根节点的键总是最小或最大（即最小堆或最大堆），并且这种性质也适用于每个子树。这意味着，堆不仅保持了树的层次关系，还额外维护了一种排序关系。")])]),v._v(" "),_("h3",{attrs:{id:"堆有两种主要类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆有两种主要类型"}},[v._v("#")]),v._v(" 堆有两种主要类型：")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("最小堆（Min Heap）")]),v._v("：父节点的键总是小于或等于其任何子节点的键。换句话说，最小的元素总是在根处。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("最大堆（Max Heap）")]),v._v("：与最小堆相反，父节点的键总是大于或等于其任何子节点的键。最大的元素总是在根处。")])])]),v._v(" "),_("h3",{attrs:{id:"优势-特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优势-特点"}},[v._v("#")]),v._v(" 优势（特点）")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("堆")]),v._v("的"),_("code",[v._v("插入和删除")]),v._v("操作通常比"),_("code",[v._v("排序算法（如快速排序、归并排序）更有效率")]),v._v("，"),_("code",[v._v("时间复杂度")]),v._v("通常为"),_("code",[v._v("O(log n)")]),v._v("，其中 "),_("code",[v._v("n")]),v._v(" 是堆中的"),_("code",[v._v("元素数量")]),v._v("。这使得"),_("code",[v._v("堆")]),v._v("非常适合实现"),_("code",[v._v("优先级队列")]),v._v("，例如在"),_("code",[v._v("任务调度")]),v._v("、"),_("code",[v._v("路由算法")]),v._v("和"),_("code",[v._v("机器学习")]),v._v("等领域都有广泛的应用。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("堆")]),v._v("可以使用"),_("code",[v._v("数组")]),v._v("或"),_("code",[v._v("链表")]),v._v("来实现，不过使用"),_("code",[v._v("数组实现")]),v._v("会"),_("code",[v._v("更加高效")]),v._v("，因为它可以"),_("code",[v._v("利用数组的索引")]),v._v("特性来"),_("code",[v._v("快速定位")]),v._v("节点及"),_("code",[v._v("其子节点")]),v._v("或"),_("code",[v._v("父节点")]),v._v("的位置。")])])])])}),[],!1,null,null,null);_.default=o.exports}}]);