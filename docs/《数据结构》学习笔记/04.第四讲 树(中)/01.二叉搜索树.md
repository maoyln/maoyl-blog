---
title: 二叉搜索树
date: 2024-06-24 20:21:41
permalink: /pages/5d67b6/
categories:
  - 《数据结构》学习笔记
  - 第四讲 树(中)
tags:
  - 
---

## 二叉搜索树

> 静态查账与动态查找
> 针对动态查找，数据如何组织

### 名称

`二叉搜索树`**（BST, Binary Search Tree）**,也称`二叉排序树`或`二叉查找树`；


### 二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：:

1. 非空`左子树`的所有`键值小于其根结点`的键值。 
2. 非空`右子树`的所有`键值大于其根结点`的键值。 
3. `左、右子树`都是`二叉搜索树`。

> **错误示例**

![错误示例](https://cdn.jsdelivr.net/gh/maoyln/maoyl-img/blog/4991720599361_.pic.jpg)

> **正确示例**

![正确示例](https://cdn.jsdelivr.net/gh/maoyln/maoyl-img/blog/5001720599372_.pic.jpg)

> **正确示例**

![正确示例](https://cdn.jsdelivr.net/gh/maoyln/maoyl-img/blog/5021720599509_.pic.jpg)

### 二叉搜索树操作的特别函数：

- 💡Position Find( ElementType X, BinTree BST )：从二叉搜索树BST中查找元素X，返回其所在结点的地址；
- 💡Position FindMin( BinTree BST )：从二叉搜索树BST中查找并返回最小元素所在结点的地址；
- 💡Position FindMax( BinTree BST ) ：从二叉搜索树BST中查找并返回最大元素所在结点的地址。 
- 💡BinTree  Insert( ElementType X, BinTree BST ) 
- 💡BinTree  Delete( ElementType X, BinTree BST ) 

#### 二叉搜索树的查找操作Find

- 查找从根结点开始，如果树为空，返回NULL
- 若搜索树非空，则根结点关键字和X进行比较，并进行不同处理：
  - 若X小于根结点键值，只需在左子树中继续搜索； 
  - 如果X大于根结点的键值，在右子树中进行继续搜索； 
  - 若两者比较结果是相等，搜索完成，返回指向此结点的指针。 


```javascript
// 递归的形式
function findNode(X, BST) {
    if (!BST) return null; // 查找失败

    if (X > BST.data) {
        return findNode(X, BST.right); // 在右子树中继续查找
    } else if (X < BST.data) {
        return findNode(X, BST.left); // 在左子树中继续查找
    } else { // X === BST.data
        return BST; // 查找成功，返回结点的地址
    }
}
```
由于`非递归函数`的执行`效率高`，可将`“尾递归”`函数改为`迭代`函数

```javascript
function findNode(X, BST) {
  while (BST) {
    if (X > BST.data) {
      BST = BST.right; // 向右子树中移动，继续查找
    } else if (X < BST.data) {
      BST = BST.left; // 向左子树中移动，继续查找
    } else { // X === BST.data
      return BST; // 查找成功，返回结点的地址
    }
  }
  return null
}
```
**`查找的效率决定于树的高度`**


### 找最大和最小元素

- `最大元素`一定是在树的`最右分枝的端结点`上
- `最小元素`一定是在树的`最左分枝的端结点`上

![找最大和最小元素](https://cdn.jsdelivr.net/gh/maoyln/maoyl-img/blog/5031720601096_.pic.jpg)

```javascript
// 查找最小元素的递归函数
function findMin(BST) {
  if (!BST) {
    return null, // /*空的二叉搜索树，返回null*/
  } else if (!BST.left) {
    return BST; //找到最左叶结点并返回
  } else {
    return findMin(BST.left)
  }
}
```

```javascript
// 查找最大元素的迭代函数
function findMin(BST) {
  if (BST) {
    while (BST.right) {
      BST = BST.right; // 沿右分支继续查找，直到最右叶结点
    }
  }
  return BST;
}
```

## 二叉搜索树的插入

>〖**分析**〗关键是要找到元素应该插入的`位置`，可以采用与`Find`类似的方法

- 在下面树上插入35
![在下面树上插入35](https://cdn.jsdelivr.net/gh/maoyln/maoyl-img/blog/5041720601776_.pic.jpg)

**二叉搜索树的插入算法**
```javascript
function insert(X, BST) {
    if (!BST) { // 若原树为空，生成并返回一个结点的二叉搜索树
        BST = { data: X, left: null, right: null };
    } else { // 开始找要插入元素的位置
        if (X < BST.data) { // 递归插入左子树
            BST.left = insert(X, BST.left);
        } else if (X > BST.data) { // 递归插入右子树
            BST.right = insert(X, BST.right);
        } // else X已经存在，什么都不做
    }
    return BST;
}
```

## 二叉搜索树的删除

考虑三种情况
- 



