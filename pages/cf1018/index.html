<h1 id="05-自定义-hook">05. 自定义 Hook</h1>

<p><strong>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。</strong></p>

<p>目前为止，在 React 中有两种流行的方式来共享组件之间的状态逻辑: <a href="https://zh-hans.reactjs.org/docs/render-props.html">render props</a> 和<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件</a>，现在让我们来看看 Hook 是如何在让你不增加组件的情况下解决相同问题的。</p>

<h2 id="提取自定义-hook">提取自定义 Hook</h2>

<p><strong>自定义 Hook 是一个函数，其名称以 “<code class="language-plaintext highlighter-rouge">use</code>” 开头，函数内部可以调用其他的 Hook。</strong> 例如，下面的 <code class="language-plaintext highlighter-rouge">useFriendStatus</code> 是我们第一个自定义的 Hook:</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useEffect</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">useFriendStatus</span><span class="p">(</span><span class="nx">friendID</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">isOnline</span><span class="p">,</span> <span class="nx">setIsOnline</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">handleStatusChange</span><span class="p">(</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">setIsOnline</span><span class="p">(</span><span class="nx">status</span><span class="p">.</span><span class="nx">isOnline</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">ChatAPI</span><span class="p">.</span><span class="nx">subscribeToFriendStatus</span><span class="p">(</span><span class="nx">friendID</span><span class="p">,</span> <span class="nx">handleStatusChange</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">ChatAPI</span><span class="p">.</span><span class="nx">unsubscribeFromFriendStatus</span><span class="p">(</span><span class="nx">friendID</span><span class="p">,</span> <span class="nx">handleStatusChange</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="nx">isOnline</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>与 React 组件不同的是，自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。换句话说，它<strong>就像一个正常的函数</strong>。但是它的名字应该始终以 <code class="language-plaintext highlighter-rouge">use</code> 开头，这样可以一眼看出其符合 <a href="https://zh-hans.reactjs.org/docs/hooks-rules.html">Hook 的规则</a>。</p>

<h2 id="使用自定义-hook">使用自定义 Hook</h2>

<p>现在我们已经把这个逻辑提取到 <code class="language-plaintext highlighter-rouge">useFriendStatus</code> 的自定义 Hook 中，然后就可以<em>使用它了：</em></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">FriendStatus</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isOnline</span> <span class="o">=</span> <span class="nx">useFriendStatus</span><span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="nx">friend</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isOnline</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">Loading...</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">isOnline</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Online</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">Offline</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">FriendListItem</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isOnline</span> <span class="o">=</span> <span class="nx">useFriendStatus</span><span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="nx">friend</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">li</span> <span class="na">style</span><span class="p">=</span><span class="si">{</span><span class="p">{</span> <span class="na">color</span><span class="p">:</span> <span class="nx">isOnline</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">green</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span> <span class="p">}</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">friend</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>这段代码等价于原来的示例代码吗？</strong>等价，它的工作方式完全一样。如果你仔细观察，你会发现我们没有对其行为做任何的改变，我们只是将两个函数之间一些共同的代码提取到单独的函数中。<strong>自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。</strong></p>

<p><strong>自定义 Hook 必须以 “<code class="language-plaintext highlighter-rouge">use</code>” 开头吗？</strong>必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 <a href="https://zh-hans.reactjs.org/docs/hooks-rules.html">Hook 的规则</a>。</p>

<p><strong>在两个组件中使用相同的 Hook 会共享 state 吗？</strong>不会。自定义 Hook 是一种重用<em>状态逻辑</em>的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。</p>

<p><strong>自定义 Hook 如何获取独立的 state？</strong>每次<em>调用</em> Hook，它都会获取独立的 state。由于我们直接调用了 <code class="language-plaintext highlighter-rouge">useFriendStatus</code>，从 React 的角度来看，我们的组件只是调用了 <code class="language-plaintext highlighter-rouge">useState</code> 和 <code class="language-plaintext highlighter-rouge">useEffect</code>。 正如我们在<a href="https://zh-hans.reactjs.org/docs/hooks-effect.html#tip-use-multiple-effects-to-separate-concerns">之前章节</a>中<a href="https://zh-hans.reactjs.org/docs/hooks-state.html#tip-using-multiple-state-variables">了解到的</a>一样，我们可以在一个组件中多次调用 <code class="language-plaintext highlighter-rouge">useState</code> 和 <code class="language-plaintext highlighter-rouge">useEffect</code>，它们是完全独立的。</p>

<p>###</p>

<h3 id="小总结">小总结</h3>

<ol>
  <li>自定义hook就像一个普通函数，内部包含可复用的组件逻辑。</li>
  <li>函数名以<code class="language-plaintext highlighter-rouge">use</code>开头。</li>
  <li><code class="language-plaintext highlighter-rouge">state</code>是独立的。</li>
</ol>

