<h1 id="mixin">Mixin</h1>

<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">网状结构</a>。
<!-- more -->
但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。</p>

<p>各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类”。凡是继承于 Interface 的方法，都必须自己定义实现，否则就会报错。这样就避免了多重继承的最大问题：多个父类的同名方法的碰撞（naming collision）。</p>

<p>JavaScript 语言没有采用 Interface 的方案，而是通过代理（delegation）实现了从其他类引入方法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Enumerable_first</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">baz</span><span class="dl">"</span><span class="p">];</span>
<span class="nx">Enumerable_first</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">list</span><span class="p">);</span> <span class="c1">// explicit delegation</span>
<span class="nx">list</span><span class="p">.</span><span class="nx">first</span><span class="p">()</span> <span class="c1">// "foo"</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">list</code>是一个数组，本身并没有<code class="language-plaintext highlighter-rouge">first</code>方法。通过<code class="language-plaintext highlighter-rouge">call</code>方法，可以把<code class="language-plaintext highlighter-rouge">Enumerable_first</code>里面的方法，绑定到<code class="language-plaintext highlighter-rouge">list</code>，从而<code class="language-plaintext highlighter-rouge">list</code>就具有<code class="language-plaintext highlighter-rouge">first</code>方法。这就叫做“代理”（delegation），<code class="language-plaintext highlighter-rouge">list</code>对象代理了<code class="language-plaintext highlighter-rouge">Enumerable_first</code>的<code class="language-plaintext highlighter-rouge">first</code>方法。</p>

<h2 id="含义">含义</h2>

<p>Mixin 这个名字来自于冰淇淋，在基本口味的冰淇淋上面混入其他口味，这就叫做 Mix-in。</p>

<p>它允许向一个类里面注入一些代码，使得一个类的功能能够“混入”另一个类。实质上是多重继承的一种解决方案，但是避免了多重继承的复杂性，而且有利于代码复用。</p>

<p>Mixin 就是一个正常的类，不仅定义了接口，还定义了接口的实现。</p>

<p>子类通过在<code class="language-plaintext highlighter-rouge">this</code>对象上面绑定方法，达到多重继承的目的。</p>

<p>很多库提供了 Mixin 功能。下面以 Lodash 为例。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">vowels</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="sr">/</span><span class="se">[</span><span class="sr">aeiou</span><span class="se">]</span><span class="sr">/i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span> <span class="p">};</span>
<span class="nx">_</span><span class="p">.</span><span class="nx">mixin</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span><span class="na">vowels</span><span class="p">:</span> <span class="nx">vowels</span><span class="p">})</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">vowels</span><span class="p">()</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>上面代码通过 Lodash 库的<code class="language-plaintext highlighter-rouge">_.mixin</code>方法，让<code class="language-plaintext highlighter-rouge">obj</code>对象继承了<code class="language-plaintext highlighter-rouge">vowels</code>方法。</p>

<p>Underscore 的类似方法是<code class="language-plaintext highlighter-rouge">_.extend</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fName</span><span class="p">,</span> <span class="nx">lName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">=</span> <span class="nx">fName</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span> <span class="o">=</span> <span class="nx">lName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">sam</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">Sam</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Lowry</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">NameMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">fullName</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="na">rename</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">first</span><span class="p">,</span> <span class="nx">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">=</span> <span class="nx">first</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span> <span class="o">=</span> <span class="nx">last</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="nx">_</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">NameMixin</span><span class="p">);</span>
<span class="nx">sam</span><span class="p">.</span><span class="nx">rename</span><span class="p">(</span><span class="dl">'</span><span class="s1">Samwise</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Gamgee</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">sam</span><span class="p">.</span><span class="nx">fullName</span><span class="p">()</span> <span class="c1">// "Samwise Gamgee"</span>
</code></pre></div></div>

<p>上面代码通过<code class="language-plaintext highlighter-rouge">_.extend</code>方法，在<code class="language-plaintext highlighter-rouge">sam</code>对象上面（准确说是它的原型对象<code class="language-plaintext highlighter-rouge">Person.prototype</code>上面），混入了<code class="language-plaintext highlighter-rouge">NameMixin</code>类。</p>

<p><code class="language-plaintext highlighter-rouge">extend</code>方法的实现非常简单。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">destination</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="k">in</span> <span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">source</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">destination</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">source</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">destination</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码将<code class="language-plaintext highlighter-rouge">source</code>对象的所有方法，添加到<code class="language-plaintext highlighter-rouge">destination</code>对象。</p>

<h2 id="trait">Trait</h2>

<p>Trait 是另外一种多重继承的解决方案。它与 Mixin 很相似，但是有一些细微的差别。</p>

<ul>
  <li>Mixin 可以包含状态（state），Trait 不包含，即 Trait 里面的方法都是互不相干，可以线性包含的。比如，<code class="language-plaintext highlighter-rouge">Trait1</code>包含方法<code class="language-plaintext highlighter-rouge">A</code>和<code class="language-plaintext highlighter-rouge">B</code>，<code class="language-plaintext highlighter-rouge">Trait2</code>继承了<code class="language-plaintext highlighter-rouge">Trait1</code>，同时还包含一个自己的方法<code class="language-plaintext highlighter-rouge">C</code>，实际上就等同于直接包含方法<code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">C</code>。</li>
  <li>对于同名方法的碰撞，Mixin 包含了解决规则，Trait 则是报错。</li>
</ul>
