<h1 id="es6面向对象">ES6面向对象</h1>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//面向对象封装</span>
<span class="kd">class</span> <span class="nx">Student</span><span class="p">{</span> <span class="c1">//定义类 (尊从首字母大写的约定)</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">){</span>  <span class="c1">// 构造函数 （构造函数内定于属性）</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">匿名</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 默认'匿名'</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">grade</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">grade</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">hello</span><span class="p">(){</span> <span class="c1">// 在构造函数的原型上定义方法</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`你好,</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">同学，你在</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">grade</span><span class="p">}</span><span class="s2">年级`</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="c1">//使用</span>
<span class="kd">function</span> <span class="nx">createStudent</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 对于new构造函数的封装，其优点：一是不需要new来调用，二是参数灵活</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Student</span><span class="p">(</span><span class="nx">props</span> <span class="o">||</span> <span class="p">{})</span> <span class="c1">// 通过new创建构造函数，并传入参数/属性</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">niming</span> <span class="o">=</span> <span class="nx">createStudent</span><span class="p">();</span> 
<span class="nx">niming</span><span class="p">.</span><span class="nx">hello</span><span class="p">();</span>

<span class="kd">let</span> <span class="nx">xiaoming</span> <span class="o">=</span> <span class="nx">createStudent</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">小明</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">grade</span><span class="p">:</span><span class="mi">2</span>
<span class="p">});</span>
<span class="nx">xiaoming</span><span class="p">.</span><span class="nx">hello</span><span class="p">();</span>



<span class="c1">//继承</span>
<span class="kd">class</span> <span class="nx">PrimaryStudent</span> <span class="kd">extends</span> <span class="nx">Student</span> <span class="p">{</span> <span class="c1">//class 子类 extends 父类</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span> <span class="c1">// 用super调用父类的构造方法实现属性继承</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">age</span> <span class="o">||</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">//新增子类属性</span>
    <span class="p">}</span>

    <span class="nx">getAge</span><span class="p">()</span> <span class="p">{</span> <span class="c1">//对子类添加方法</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">同学，你今年</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">}</span><span class="s2">岁`</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//使用继承后的</span>
<span class="kd">function</span> <span class="nx">createPrimaryStudent</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 对于new构造函数的封装，其优点：一是不需要再new来调用，二是参数灵活</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">PrimaryStudent</span><span class="p">(</span><span class="nx">props</span> <span class="o">||</span> <span class="p">{})</span> <span class="c1">// 通过new创建构造函数，并传入参数/属性</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">xiaohong</span> <span class="o">=</span> <span class="nx">createPrimaryStudent</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">小红</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">grade</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span><span class="mi">10</span>
<span class="p">});</span>
<span class="nx">xiaohong</span><span class="p">.</span><span class="nx">hello</span><span class="p">();</span>
<span class="nx">xiaohong</span><span class="p">.</span><span class="nx">getAge</span><span class="p">();</span>
</code></pre></div></div>

