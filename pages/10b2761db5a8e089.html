<h1 id="事件">事件</h1>

<h2 id="一eventtarget-接口">一、EventTarget 接口</h2>

<p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 <strong>DOM 的事件编程</strong>。</p>

<h3 id="1概述">1、概述</h3>

<p><strong>DOM 的事件操作（监听和触发），都定义在<code class="language-plaintext highlighter-rouge">EventTarget</code>接口</strong>。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code class="language-plaintext highlighter-rouge">XMLHttpRequest</code>、<code class="language-plaintext highlighter-rouge">AudioNode</code>、<code class="language-plaintext highlighter-rouge">AudioContext</code>）也部署了这个接口。</p>

<p>该接口主要提供三个实例方法。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">addEventListener</code>：绑定事件的监听函数</li>
  <li><code class="language-plaintext highlighter-rouge">removeEventListener</code>：移除事件的监听函数</li>
  <li><code class="language-plaintext highlighter-rouge">dispatchEvent</code>：触发事件</li>
</ul>

<h3 id="2eventtargetaddeventlistener">2、EventTarget.addEventListener()</h3>

<p><code class="language-plaintext highlighter-rouge">EventTarget.addEventListener()</code>用于<strong>在当前节点或对象上，定义一个特定事件的监听函数</strong>。<strong>一旦这个事件发生，就会执行监听函数</strong>。该方法没有返回值。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">target</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">listener</span><span class="p">[,</span> <span class="nx">useCapture</span><span class="p">]);</span>
<span class="c1">// 事件名称，监听函数 [，是否在捕获阶段触发]</span>
</code></pre></div></div>

<p>该方法接受三个参数。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">type</code>：事件名称，大小写敏感。</li>
  <li><code class="language-plaintext highlighter-rouge">listener</code>：监听函数。事件发生时，会调用该监听函数。</li>
  <li><code class="language-plaintext highlighter-rouge">useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code class="language-plaintext highlighter-rouge">false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li>
</ul>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello world</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">button</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">btn</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">button</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">hello</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">button</code>节点的<code class="language-plaintext highlighter-rouge">addEventListener</code>方法绑定<code class="language-plaintext highlighter-rouge">click</code>事件的监听函数<code class="language-plaintext highlighter-rouge">hello</code>，该函数只在冒泡阶段触发。</p>

<p>关于参数，有两个地方需要注意。</p>

<p>首先，第二个参数除了监听函数，还可以是一个具有<code class="language-plaintext highlighter-rouge">handleEvent</code>方法的对象。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">buttonElement</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">handleEvent</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">addEventListener</code>方法的第二个参数，就是一个具有<code class="language-plaintext highlighter-rouge">handleEvent</code>方法的对象。</p>

<p>其次，<strong>第三个参数除了布尔值<code class="language-plaintext highlighter-rouge">useCapture</code>，还可以是一个属性配置对象</strong>。该对象有以下属性。</p>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">capture</code>：布尔值，表示该事件是否在<code class="language-plaintext highlighter-rouge">捕获阶段</code>触发监听函数。</li>
    <li><code class="language-plaintext highlighter-rouge">once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li>
    <li><code class="language-plaintext highlighter-rouge">passive</code>：布尔值，表示监听函数不会调用事件的<code class="language-plaintext highlighter-rouge">preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li>
  </ul>
</blockquote>

<p>如果希望事件监听函数<strong>只执行一次</strong>，可以打开属性配置对象的<code class="language-plaintext highlighter-rouge">once</code>属性。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 只执行一次的代码</span>
<span class="p">},</span> <span class="p">{</span><span class="na">once</span><span class="p">:</span> <span class="kc">true</span><span class="p">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code class="language-plaintext highlighter-rouge">removeEventListener</code>方法手动去除）。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello world</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">hello</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">hello</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>执行上面代码，点击文档只会输出一行<code class="language-plaintext highlighter-rouge">Hello world</code>。</p>

<p>如果<strong>希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">print</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">div1</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="nx">print</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span> <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码通过匿名函数，向监听函数<code class="language-plaintext highlighter-rouge">print</code>传递了一个参数。</p>

<p>监听函数<strong>内部的<code class="language-plaintext highlighter-rouge">this</code>，指向当前事件所在的那个对象。</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;p id="para"&gt;Hello&lt;/p&gt;</span>
<span class="kd">var</span> <span class="nx">para</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">para</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">nodeName</span><span class="p">);</span> <span class="c1">// "P"</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，监听函数内部的<code class="language-plaintext highlighter-rouge">this</code>指向事件所在的对象<code class="language-plaintext highlighter-rouge">para</code>。</p>

<h3 id="3eventtargetremoveeventlistener">3、EventTarget.removeEventListener()</h3>

<p><code class="language-plaintext highlighter-rouge">EventTarget.removeEventListener</code>方法<strong>用来移除<code class="language-plaintext highlighter-rouge">addEventListener</code>方法添加的事件监听函数</strong>。该方法没有返回值。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">removeEventListener</code>方法的参数，与<code class="language-plaintext highlighter-rouge">addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>

<p>注意，<code class="language-plaintext highlighter-rouge">removeEventListener</code>方法移除的监听函数，必须是<code class="language-plaintext highlighter-rouge">addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{},</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{},</span> <span class="kc">false</span><span class="p">);</span><span class="c1">// 移除无效，因为不是同一个监听函数</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">removeEventListener</code>方法无效，因为监听函数不是同一个匿名函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mousedown</span><span class="dl">'</span><span class="p">,</span> <span class="nx">handleMouseDown</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">mousedown</span><span class="dl">"</span><span class="p">,</span> <span class="nx">handleMouseDown</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// 移除无效，第三个参数不一样</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p>

<h3 id="4eventtargetdispatchevent">4、EventTarget.dispatchEvent()</h3>

<p><code class="language-plaintext highlighter-rouge">EventTarget.dispatchEvent</code>方法在当前节点上<strong>触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值</strong>，只要有一个监听函数调用了<code class="language-plaintext highlighter-rouge">Event.preventDefault()</code>，则返回值为<code class="language-plaintext highlighter-rouge">false</code>，否则为<code class="language-plaintext highlighter-rouge">true</code>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">target</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">dispatchEvent</code>方法的<strong>参数是一个<code class="language-plaintext highlighter-rouge">Event</code>对象的实例</strong>（详见《Event 对象》章节）。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">para</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">hello</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">para</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码在当前节点触发了<code class="language-plaintext highlighter-rouge">click</code>事件。</p>

<p>如果<code class="language-plaintext highlighter-rouge">dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</p>

<p>下面代码根据<code class="language-plaintext highlighter-rouge">dispatchEvent</code>方法的返回值，<strong>判断事件是否被取消</strong>了。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">canceled</span> <span class="o">=</span> <span class="o">!</span><span class="nx">cb</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">canceled</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">事件取消</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">事件未取消</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="二事件模型">二、事件模型</h2>

<h3 id="1监听函数">1、监听函数</h3>

<p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>

<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>

<h4 id="12-html-的-on--属性">1.2 HTML 的 on- 属性</h4>

<p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body</span> <span class="na">onload=</span><span class="s">"doSomething()"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- 加圆括号--&gt;</span>
<span class="nt">&lt;div</span> <span class="na">onclick=</span><span class="s">"console.log('触发事件')"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>上面代码为<code class="language-plaintext highlighter-rouge">body</code>节点的<code class="language-plaintext highlighter-rouge">load</code>事件、<code class="language-plaintext highlighter-rouge">div</code>节点的<code class="language-plaintext highlighter-rouge">click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>

<p>元素的事件监听属性，都是<code class="language-plaintext highlighter-rouge">on</code>加上事件名，比如<code class="language-plaintext highlighter-rouge">onload</code>就是<code class="language-plaintext highlighter-rouge">on + load</code>，表示<code class="language-plaintext highlighter-rouge">load</code>事件的监听代码。</p>

<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 正确 --&gt;</span>
<span class="nt">&lt;body</span> <span class="na">onload=</span><span class="s">"doSomething()"</span><span class="nt">&gt;</span>

<span class="c">&lt;!-- 错误 --&gt;</span>
<span class="nt">&lt;body</span> <span class="na">onload=</span><span class="s">"doSomething"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>一旦指定的事件发生，<code class="language-plaintext highlighter-rouge">on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，<strong>不要忘记加上一对圆括号</strong>。</p>

<p>使用这个方法指定的监听代码，只会在<strong>冒泡阶段触发</strong>。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">onClick=</span><span class="s">"console.log(2)"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;button</span> <span class="na">onClick=</span><span class="s">"console.log(1)"</span><span class="nt">&gt;</span>点击<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge"> &lt;button&gt; </code>是<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>的子元素。<code class="language-plaintext highlighter-rouge">&lt;button&gt;</code>的<code class="language-plaintext highlighter-rouge">click</code>事件，也会触发<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>的<code class="language-plaintext highlighter-rouge">click</code>事件。由于<code class="language-plaintext highlighter-rouge">on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code class="language-plaintext highlighter-rouge">1</code>，再输出<code class="language-plaintext highlighter-rouge">2</code>，即事件<strong>从子元素开始冒泡到父元素。</strong></p>

<p>直接设置<code class="language-plaintext highlighter-rouge">on-</code>属性，与通过元素节点的<code class="language-plaintext highlighter-rouge">setAttribute</code>方法设置<code class="language-plaintext highlighter-rouge">on-</code>属性，效果是一样的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="dl">'</span><span class="s1">onclick</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">doSomething()</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="c1">// &lt;Element onclick="doSomething()"&gt;</span>
</code></pre></div></div>

<h4 id="12-元素节点的事件属性-例elonclick">1.2 元素节点的事件属性 (例：el.onclick)</h4>

<p>元素节点对象的<strong>事件属性</strong>，同样可以指定监听函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">doSomething</span><span class="p">;</span> <span class="c1">// 注意这里是函数名，不加圆括号</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// onclick是元素的一个属性，它指向一个函数，在触发点击时执行此函数</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">触发事件</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>使用这个方法指定的监听函数，也是只会在<strong>冒泡阶段触发</strong>。</p>

<p>注意，这种方法与 HTML 的<code class="language-plaintext highlighter-rouge">on-</code>属性的差异是，它的值是函数名（<code class="language-plaintext highlighter-rouge">doSomething</code>），而不像后者，必须给出完整的监听代码（<code class="language-plaintext highlighter-rouge">doSomething()</code>）。</p>

<h4 id="13-eventtargetaddeventlistener">1.3 EventTarget.addEventListener()</h4>

<p><strong>所有 DOM 节点实例都有<code class="language-plaintext highlighter-rouge">addEventListener</code>方法</strong>，用来为该节点定义事件的监听函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="nx">doSomething</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// 注意这里是函数名，不加圆括号</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">addEventListener</code>方法的详细介绍，参见<code class="language-plaintext highlighter-rouge">EventTarget</code>章节。</p>

<h4 id="14-小结">1.4 小结</h4>

<p>上面三种方法，</p>

<p>第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此<strong>不推荐使用</strong>。</p>

<p>第二种“元素节点的事件属性”的<strong>缺点</strong>在于，<strong>同一个事件只能定义一个监听函数</strong>，也就是说，如果定义两次<code class="language-plaintext highlighter-rouge">onclick</code>属性，后一次定义会覆盖前一次。因此，<strong>也不推荐使用</strong>。</p>

<p>第三种<code class="language-plaintext highlighter-rouge">EventTarget.addEventListener</code>是<strong>推荐的指定监听函数的方法</strong>。它有如下优点：</p>

<ul>
  <li>同一个事件可以添加多个监听函数。</li>
  <li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>
  <li>除了 DOM 节点，其他对象（比如<code class="language-plaintext highlighter-rouge">window</code>、<code class="language-plaintext highlighter-rouge">XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>

<h3 id="2this-的指向-指向元素节点">2、this 的指向 （指向元素节点）</h3>

<p><strong>监听函数内部的<code class="language-plaintext highlighter-rouge">this</code>指向触发事件的那个元素节点。（三种事件绑定的this全指向元素节点）</strong></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">"btn"</span> <span class="na">onclick=</span><span class="s">"console.log(this.id)"</span><span class="nt">&gt;</span>点击<span class="nt">&lt;/button&gt;</span>
</code></pre></div></div>

<p>执行上面代码，点击后会输出<code class="language-plaintext highlighter-rouge">btn</code>。</p>

<p>其他两种监听函数的写法，<code class="language-plaintext highlighter-rouge">this</code>的指向也是如此。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;button id="btn"&gt;点击&lt;/button&gt;</span>
<span class="kd">var</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">btn</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 写法一</span>
<span class="nx">btn</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 写法二</span>
<span class="nx">btn</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="kc">false</span>
<span class="p">);</span>
</code></pre></div></div>

<p>上面两种写法，点击按钮以后也是输出<code class="language-plaintext highlighter-rouge">btn</code>。</p>

<h3 id="3事件的传播捕获目标冒泡">3、事件的传播（捕获、目标、冒泡）</h3>

<p>一个事件发生后，会<strong>在子元素和父元素之间传播</strong>（propagation）。这种传播分成三个阶段。</p>

<ul>
  <li><strong>第一阶段</strong>：从<code class="language-plaintext highlighter-rouge">window</code>对象传导到目标节点（上层传到底层），称为“<strong>捕获阶段</strong>”（capture phase）。</li>
  <li><strong>第二阶段</strong>：在目标节点上触发，称为“<strong>目标阶段</strong>”（target phase）。</li>
  <li><strong>第三阶段</strong>：从目标节点传导回<code class="language-plaintext highlighter-rouge">window</code>对象（从底层传回上层），称为“<strong>冒泡阶段</strong>”（bubbling phase）。</li>
</ul>

<p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div&gt;</span>
  <span class="nt">&lt;p&gt;</span>点击<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>节点之中有一个<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>节点。</p>

<p>如果对这两个节点，都设置<code class="language-plaintext highlighter-rouge">click</code>事件的监听函数（每个节点的捕获阶段和冒泡阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>点击，<code class="language-plaintext highlighter-rouge">click</code>事件会触发四次。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">phases</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">capture</span><span class="dl">'</span><span class="p">,</span>
  <span class="mi">2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">target</span><span class="dl">'</span><span class="p">,</span>
  <span class="mi">3</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bubble</span><span class="dl">'</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// true 表示在捕获阶段触发</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// true 表示在捕获阶段触发</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span><span class="c1">// fasle 表示在冒泡阶段触发</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// fasle 表示在冒泡阶段触发</span>

<span class="kd">function</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tag</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">currentTarget</span><span class="p">.</span><span class="nx">tagName</span><span class="p">;</span> <span class="c1">// 当前目标对象的标签名</span>
  <span class="kd">var</span> <span class="nx">phase</span> <span class="o">=</span> <span class="nx">phases</span><span class="p">[</span><span class="nx">event</span><span class="p">.</span><span class="nx">eventPhase</span><span class="p">];</span> <span class="c1">// 触发的阶段</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tag: '</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tag</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">'. EventPhase: '</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">phase</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">'</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 点击以后的结果</span>
<span class="c1">// Tag: 'DIV'. EventPhase: 'capture'  捕获阶段</span>
<span class="c1">// Tag: 'P'. EventPhase: 'target' 目标阶段</span>
<span class="c1">// Tag: 'P'. EventPhase: 'target' 目标阶段</span>
<span class="c1">// Tag: 'DIV'. EventPhase: 'bubble' 冒泡阶段</span>
</code></pre></div></div>

<p>上面代码表示，<code class="language-plaintext highlighter-rouge">click</code>事件被触发了四次：<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>节点的捕获阶段和冒泡阶段各1次，<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>节点的目标阶段触发了2次。</p>

<ol>
  <li>捕获阶段：事件从<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>向<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>传播时，触发<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>的<code class="language-plaintext highlighter-rouge">click</code>事件；</li>
  <li>目标阶段：事件从<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>到达<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>时，触发<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>的<code class="language-plaintext highlighter-rouge">click</code>事件；</li>
  <li>冒泡阶段：事件从<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>传回<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>时，再次触发<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>的<code class="language-plaintext highlighter-rouge">click</code>事件。</li>
</ol>

<p>其中，<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>节点有两个监听函数（<code class="language-plaintext highlighter-rouge">addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为<code class="language-plaintext highlighter-rouge">click</code>事件触发一次。所以，<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>会在<code class="language-plaintext highlighter-rouge">target</code>阶段有两次输出。</p>

<p><strong>注意</strong>，<strong>浏览器总是假定<code class="language-plaintext highlighter-rouge">click</code>事件的目标节点，就是点击位置嵌套最深的那个节点</strong>（本例是<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>节点里面的<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>节点）。所以，<strong><code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>节点的捕获阶段和冒泡阶段，都会显示为<code class="language-plaintext highlighter-rouge">target</code>阶段。</strong></p>

<p>事件传播的最上层对象是<code class="language-plaintext highlighter-rouge">window</code>，接着依次是<code class="language-plaintext highlighter-rouge">document</code>，<code class="language-plaintext highlighter-rouge">html</code>（<code class="language-plaintext highlighter-rouge">document.documentElement</code>）和<code class="language-plaintext highlighter-rouge">body</code>（<code class="language-plaintext highlighter-rouge">document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code class="language-plaintext highlighter-rouge">window</code>、<code class="language-plaintext highlighter-rouge">document</code>、<code class="language-plaintext highlighter-rouge">html</code>、<code class="language-plaintext highlighter-rouge">body</code>、<code class="language-plaintext highlighter-rouge">div</code>、<code class="language-plaintext highlighter-rouge">p</code>，在冒泡阶段依次为<code class="language-plaintext highlighter-rouge">p</code>、<code class="language-plaintext highlighter-rouge">div</code>、<code class="language-plaintext highlighter-rouge">body</code>、<code class="language-plaintext highlighter-rouge">html</code>、<code class="language-plaintext highlighter-rouge">document</code>、<code class="language-plaintext highlighter-rouge">window</code>。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>捕获阶段：
window(浏览器对象)--&gt; document(文档对象) --&gt; html --&gt; body --&gt; div --&gt; p (点击目标，在目标阶段)

冒泡阶段：
p (点击目标，在目标阶段)--&gt; div --&gt; body --&gt; html --&gt; document(文档对象) --&gt; window(浏览器对象)
</code></pre></div></div>

<h3 id="4事件的代理">4、事件的代理</h3>

<p>由于事件会在冒泡阶段向上传播到父节点，因此可以把<strong>子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理</strong>（delegation）。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">ul</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">ul</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">tagName</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">li</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 浏览器假定click嵌套最深的元素是目标元素</span>
    <span class="c1">// some code</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">click</code>事件的监听函数定义在<code class="language-plaintext highlighter-rouge"> &lt;ul&gt; </code>节点，但是实际上，它处理的是子节点<code class="language-plaintext highlighter-rouge"> &lt;li&gt; </code>的<code class="language-plaintext highlighter-rouge">click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<code class="language-plaintext highlighter-rouge"> &lt;li&gt; </code>节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p>

<h5 id="阻止事件冒泡-eventstoppropagation">阻止事件冒泡 event.stopPropagation()</h5>

<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code class="language-plaintext highlighter-rouge">stopPropagation</code>方法。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 事件传播到 p 元素后，就不再向下传播了</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span> <span class="c1">// 该方法在事件对象event上</span>
<span class="p">},</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// true表示在捕获阶段绑定事件监听函数</span>

<span class="c1">// 事件冒泡到 p 元素后，就不再向上冒泡了</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// false表示在冒泡阶段（默认值）绑定事件监听函数</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>

<p>但是，<strong><code class="language-plaintext highlighter-rouge">stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>节点的其他<code class="language-plaintext highlighter-rouge">click</code>事件的监听函数</strong>。也就是说，不是彻底取消<code class="language-plaintext highlighter-rouge">click</code>事件。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">p</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 会触发</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">p</code>元素绑定了两个<code class="language-plaintext highlighter-rouge">click</code>事件的监听函数。<code class="language-plaintext highlighter-rouge">stopPropagation</code>方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是1，然后是2。</p>

<p>如果<strong>想要彻底取消该事件</strong>，不再触发后面所有<code class="language-plaintext highlighter-rouge">click</code>的监听函数，<strong>可以使用<code class="language-plaintext highlighter-rouge">stopImmediatePropagation()</code>方法</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">p</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">stopImmediatePropagation</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 不会被触发</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">stopImmediatePropagation</code>方法可以彻底取消这个事件，使得后面绑定的所有<code class="language-plaintext highlighter-rouge">click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p>

<h2 id="三event-对象">三、Event 对象</h2>

<h3 id="1-概述">1. 概述</h3>

<p><strong>事件发生以后，会产生一个事件对象，作为参数传给监听函数</strong>。浏览器原生提供一个<code class="language-plaintext highlighter-rouge">Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code class="language-plaintext highlighter-rouge">Event.prototype</code>对象。</p>

<p><strong><code class="language-plaintext highlighter-rouge">Event</code>对象本身就是一个构造函数，可以用来生成新的实例</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Event</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span><span class="c1">// 参数一，事件名称； 参数二，事件对象的配置对象</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Event</code>构造函数接受两个参数。第一个参数<code class="language-plaintext highlighter-rouge">type</code>是字符串，表示事件的名称；第二个参数<code class="language-plaintext highlighter-rouge">options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bubbles</code>：布尔值，可选，默认为<code class="language-plaintext highlighter-rouge">false</code>，表示事件对象<strong>是否冒泡</strong>。</li>
  <li><code class="language-plaintext highlighter-rouge">cancelable</code>：布尔值，可选，默认为<code class="language-plaintext highlighter-rouge">false</code>，表示事件<strong>是否可以被取消</strong>，即能否用<code class="language-plaintext highlighter-rouge">Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">ev</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Event</span><span class="p">(</span> <span class="c1">// 创建一个新的事件实例</span>
  <span class="dl">'</span><span class="s1">look</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 事件名称</span>
  <span class="p">{</span> <span class="c1">// 事件配置</span>
    <span class="dl">'</span><span class="s1">bubbles</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 事件是否冒泡</span>
    <span class="dl">'</span><span class="s1">cancelable</span><span class="dl">'</span><span class="p">:</span> <span class="kc">false</span> <span class="c1">// 事件是否可以被取消</span>
  <span class="p">}</span>
<span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">ev</span><span class="p">);</span> <span class="c1">// 触发ev实例，该实例是look事件</span>
</code></pre></div></div>

<p>上面代码新建一个<code class="language-plaintext highlighter-rouge">look</code>事件实例，然后使用<code class="language-plaintext highlighter-rouge">dispatchEvent</code>方法触发该事件。</p>

<p>注意，如果不是显式指定<code class="language-plaintext highlighter-rouge">bubbles</code>属性为<code class="language-plaintext highlighter-rouge">true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tag</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">currentTarget</span><span class="p">.</span><span class="nx">tagName</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Tag: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">tag</span><span class="p">);</span> <span class="c1">// 没有任何输出</span>
<span class="p">}</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// 该事件是在冒泡阶段监听函数</span>

<span class="kd">var</span> <span class="nx">click</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">click</span><span class="p">);</span> <span class="c1">// 给p发出一个click事件，该事件默认不会冒泡，因此不会触发父元素div的click事件</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">p</code>元素发出一个<code class="language-plaintext highlighter-rouge">click</code>事件，该事件默认不会冒泡。<code class="language-plaintext highlighter-rouge">div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code class="language-plaintext highlighter-rouge">div.addEventListener('click', callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p>

<p>另一方面，如果这个事件在<code class="language-plaintext highlighter-rouge">div</code>元素上触发。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">div</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">click</span><span class="p">);</span>
</code></pre></div></div>

<p>那么，不管<code class="language-plaintext highlighter-rouge">div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code class="language-plaintext highlighter-rouge">div</code>元素是事件的目标，不存在是否冒泡的问题，<code class="language-plaintext highlighter-rouge">div</code>元素总是会接收到事件，因此导致监听函数生效。</p>

<h3 id="2-实例属性">2. 实例属性</h3>

<h4 id="21-eventbubbles-是否会冒泡只读eventeventphase-返回整数表示事件所处阶段只读">2.1 Event.bubbles 是否会冒泡，只读，Event.eventPhase 返回整数，表示事件所处阶段，只读</h4>

<p><code class="language-plaintext highlighter-rouge">Event.bubbles</code>属性<strong>返回一个布尔值，表示当前事件是否会冒泡</strong>。该属性为<strong>只读</strong>属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code class="language-plaintext highlighter-rouge">Event</code>构造函数生成的事件，默认是不冒泡的。</p>

<p><code class="language-plaintext highlighter-rouge">Event.eventPhase</code>属性<strong>返回一个整数常量，表示事件目前所处的阶段。该属性只读</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">phase</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">eventPhase</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Event.eventPhase</code>的返回值有四种可能。</p>

<ul>
  <li>0，事件目前<strong>没有发生</strong>。</li>
  <li>1，事件目前处于<strong>捕获阶段</strong>，即处于从祖先节点向目标节点的传播过程中。</li>
  <li>2，事件<strong>到达目标节点</strong>，即<code class="language-plaintext highlighter-rouge">Event.target</code>属性指向的那个节点。</li>
  <li>3，事件处于<strong>冒泡阶段</strong>，即处于从目标节点向祖先节点的反向传播过程中。</li>
</ul>

<h4 id="22-eventcancelable-是否可取消默认行为eventcancelbubble是否阻止冒泡eventdefaultprevented-是否调用过取消默认行为方法">2.2 Event.cancelable 是否可取消默认行为，Event.cancelBubble是否阻止冒泡，event.defaultPrevented 是否调用过取消默认行为方法</h4>

<p><code class="language-plaintext highlighter-rouge">Event.cancelable</code>属性<strong>返回一个布尔值，表示事件是否可以取消</strong>。该属性为<strong>只读</strong>属性，一般用来了解 Event 实例的特性。</p>

<p><strong>大多数浏览器的原生事件是可以取消的</strong>。比如，取消<code class="language-plaintext highlighter-rouge">click</code>事件，点击链接将无效。但是除非显式声明，<code class="language-plaintext highlighter-rouge">Event</code>构造函数生成的事件，<strong>默认是不可以取消的</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">evt</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">evt</span><span class="p">.</span><span class="nx">cancelable</span>  <span class="c1">// false 默认不可取消</span>
</code></pre></div></div>

<p>当<code class="language-plaintext highlighter-rouge">Event.cancelable</code>属性为<code class="language-plaintext highlighter-rouge">true</code>时，调用<code class="language-plaintext highlighter-rouge">Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p>

<p>如果事件不能取消，调用<code class="language-plaintext highlighter-rouge">Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code class="language-plaintext highlighter-rouge">Event.cancelable</code>属性判断一下是否可以取消。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">preventEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">cancelable</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="dl">'</span><span class="s1">This event couldn</span><span class="se">\'</span><span class="s1">t be canceled.</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Event.cancelBubble</code>属性是一个布尔值，如果设为<code class="language-plaintext highlighter-rouge">true</code>，相当于执行<code class="language-plaintext highlighter-rouge">Event.stopPropagation()</code>，可以<strong>阻止事件的传播。</strong></p>

<p><code class="language-plaintext highlighter-rouge">Event.defaultPrevented</code>属性返回一个布尔值，表示该事件<strong>是否调用过<code class="language-plaintext highlighter-rouge">Event.preventDefault</code>方法。该属性只读。</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">defaultPrevented</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">该事件已经取消了</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="23-eventcurrenttarget当前正在通过的节点eventtarget目标节点">2.3 Event.currentTarget当前正在通过的节点，Event.target目标节点</h4>

<p>事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意时点都有两个与事件相关的节点，一个是事件的<strong>原始触发节点</strong>（<code class="language-plaintext highlighter-rouge">Event.target</code>），另一个是事件<strong>当前正在通过的节点</strong>（<code class="language-plaintext highlighter-rouge">Event.currentTarget</code>）。<strong>前者通常是后者的后代节点</strong>。</p>

<p><code class="language-plaintext highlighter-rouge">Event.currentTarget</code>属性返回事件<strong>当前所在的节点</strong>，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。<strong>随着事件的传播，这个属性的值会变</strong>。</p>

<p><code class="language-plaintext highlighter-rouge">Event.target</code>属性返回<strong>原始触发事件的那个节点</strong>，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</p>

<p>事件传播过程中，不同节点的监听函数内部的<code class="language-plaintext highlighter-rouge">Event.target</code>与<code class="language-plaintext highlighter-rouge">Event.currentTarget</code>属性的值是不一样的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;p id="para"&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;</span>
<span class="kd">function</span> <span class="nx">hide</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 不管点击 Hello 或 World，总是返回 true</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">e</span><span class="p">.</span><span class="nx">currentTarget</span><span class="p">);</span>

  <span class="c1">// 点击 Hello，返回 true</span>
  <span class="c1">// 点击 World，返回 false</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">para</span><span class="dl">'</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">hide</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge"> &lt;em&gt; </code>是<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>的子节点，点击<code class="language-plaintext highlighter-rouge"> &lt;em&gt; </code>或者点击<code class="language-plaintext highlighter-rouge">  &lt;p&gt;  </code>，都会导致监听函数执行。这时，<code class="language-plaintext highlighter-rouge">e.target</code>总是指向原始点击位置的那个节点，而<code class="language-plaintext highlighter-rouge">e.currentTarget</code>指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以<code class="language-plaintext highlighter-rouge">e.currentTarget</code>总是等同于监听函数内部的<code class="language-plaintext highlighter-rouge">this</code>。</p>

<h4 id="24-eventtype-事件类型如click">2.4 Event.type 事件类型（如：’click’）</h4>

<p><code class="language-plaintext highlighter-rouge">Event.type</code>属性<strong>返回一个字符串，表示事件类型</strong>。事件的类型是在生成事件的时候指定的。该属性只读。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">evt</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">evt</span><span class="p">.</span><span class="nx">type</span> <span class="c1">// "foo"</span>
</code></pre></div></div>

<h4 id="25-eventtimestamp-相对于打开网页后的毫秒时间戳">2.5 Event.timeStamp 相对于打开网页后的毫秒时间戳</h4>

<p><code class="language-plaintext highlighter-rouge">Event.timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">evt</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">evt</span><span class="p">.</span><span class="nx">timeStamp</span> <span class="c1">// 3683.6999999995896</span>
</code></pre></div></div>

<p>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p>

<p>下面是一个<strong>计算鼠标移动速度的例子</strong>，显示每秒移动的像素数量。</p>

<h6 id="例子计算鼠标移动速度">例子：计算鼠标移动速度</h6>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">previousX</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">previousY</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">previousT</span><span class="p">;</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mousemove</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span>
    <span class="nx">previousX</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span>
    <span class="nx">previousY</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span>
    <span class="nx">previousT</span> <span class="o">!==</span> <span class="kc">undefined</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">deltaX</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">screenX</span> <span class="o">-</span> <span class="nx">previousX</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">deltaY</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">screenY</span> <span class="o">-</span> <span class="nx">previousY</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">deltaD</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="nx">deltaX</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="nx">deltaY</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

    <span class="kd">var</span> <span class="nx">deltaT</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">timeStamp</span> <span class="o">-</span> <span class="nx">previousT</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">deltaD</span> <span class="o">/</span> <span class="nx">deltaT</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">previousX</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">screenX</span><span class="p">;</span>
  <span class="nx">previousY</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">screenY</span><span class="p">;</span>
  <span class="nx">previousT</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">timeStamp</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<h4 id="26-eventistrusted-是否由真实用户行为产生的事件">2.6 Event.isTrusted 是否由真实用户行为产生的事件</h4>

<p><code class="language-plaintext highlighter-rouge">Event.isTrusted</code>属性返回一个<strong>布尔值</strong>，表示<strong>该事件是否由真实的用户行为产生</strong>。比如，用户点击链接会产生一个<code class="language-plaintext highlighter-rouge">click</code>事件，该事件是用户产生的；<code class="language-plaintext highlighter-rouge">Event</code>构造函数生成的事件，则是脚本产生的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">evt</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">evt</span><span class="p">.</span><span class="nx">isTrusted</span> <span class="c1">// false</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">evt</code>对象是脚本产生的，所以<code class="language-plaintext highlighter-rouge">isTrusted</code>属性返回<code class="language-plaintext highlighter-rouge">false</code>。</p>

<h4 id="27-eventdetail-事件的细节单击or双击等">2.7 Event.detail 事件的细节（单击or双击等）</h4>

<p><code class="language-plaintext highlighter-rouge">Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code class="language-plaintext highlighter-rouge">click</code>和<code class="language-plaintext highlighter-rouge">dblclick</code>事件，<code class="language-plaintext highlighter-rouge">Event.detail</code>是鼠标按下的次数（<code class="language-plaintext highlighter-rouge">1</code>表示单击，<code class="language-plaintext highlighter-rouge">2</code>表示双击，<code class="language-plaintext highlighter-rouge">3</code>表示三击）；对于鼠标滚轮事件，<code class="language-plaintext highlighter-rouge">Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;p&gt;Hello&lt;/p&gt;</span>
<span class="kd">function</span> <span class="nx">giveDetails</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">detail</span><span class="p">);</span> <span class="c1">// 快速点击的次数</span>
<span class="p">}</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">onclick</span> <span class="o">=</span> <span class="nx">giveDetails</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="3实例方法">3、实例方法</h3>

<h4 id="31-eventpreventdefault--取消浏览器对当前事件的默认行为">3.1 Event.preventDefault()  取消浏览器对当前事件的默认行为</h4>

<p><code class="language-plaintext highlighter-rouge">Event.preventDefault</code>方法<strong>取消浏览器对当前事件的默认行为</strong>。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code class="language-plaintext highlighter-rouge">cancelable</code>属性为<code class="language-plaintext highlighter-rouge">true</code>，如果为<code class="language-plaintext highlighter-rouge">false</code>，调用该方法没有任何效果。</p>

<p><strong>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播</strong>。如果要阻止传播，可以使用<code class="language-plaintext highlighter-rouge">stopPropagation()</code>或<code class="language-plaintext highlighter-rouge">stopImmediatePropagation()</code>方法。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;input type="checkbox" id="my-checkbox" /&gt;</span>
<span class="kd">var</span> <span class="nx">cb</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">my-checkbox</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">cb</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span> <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span> <span class="p">},</span>
  <span class="kc">false</span>
<span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p>

<p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p>

<h6 id="例子只能输入字母的输入框">例子：只能输入字母的输入框</h6>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;input type="text" id="my-input" /&gt;</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">my-input</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">input</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">keypress</span><span class="dl">'</span><span class="p">,</span> <span class="nx">checkName</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">checkName</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">charCode</span> <span class="o">&lt;</span> <span class="mi">97</span> <span class="o">||</span> <span class="nx">e</span><span class="p">.</span><span class="nx">charCode</span> <span class="o">&gt;</span> <span class="mi">122</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码为文本框的<code class="language-plaintext highlighter-rouge">keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p>

<h4 id="32-eventstoppropagation-阻止事件传播">3.2 Event.stopPropagation() 阻止事件传播</h4>

<p><code class="language-plaintext highlighter-rouge">stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">stopEvent</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span> <span class="c1">// 阻止事件冒泡</span>
<span class="p">}</span>

<span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">stopEvent</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">click</code>事件将不会进一步冒泡到<code class="language-plaintext highlighter-rouge">el</code>节点的父节点。</p>

<h4 id="33-eventstopimmediatepropagation-阻止同一个事件的其他监听函数被调用">3.3 Event.stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用</h4>

<p><code class="language-plaintext highlighter-rouge">Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code class="language-plaintext highlighter-rouge">Event.stopPropagation()</code>更彻底。</p>

<p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code class="language-plaintext highlighter-rouge">Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">l1</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">stopImmediatePropagation</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">l2</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span> <span class="c1">// 不会被调用</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">l1</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">l2</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码在<code class="language-plaintext highlighter-rouge">el</code>节点上，为<code class="language-plaintext highlighter-rouge">click</code>事件添加了两个监听函数<code class="language-plaintext highlighter-rouge">l1</code>和<code class="language-plaintext highlighter-rouge">l2</code>。由于<code class="language-plaintext highlighter-rouge">l1</code>调用了<code class="language-plaintext highlighter-rouge">event.stopImmediatePropagation</code>方法，所以<code class="language-plaintext highlighter-rouge">l2</code>不会被调用。</p>

<h4 id="34-eventcomposedpath-数组目标和冒泡的节点">3.4 Event.composedPath() 数组，目标和冒泡的节点</h4>

<p><code class="language-plaintext highlighter-rouge">Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div&gt;</span>
<span class="c1">//   &lt;p&gt;Hello&lt;/p&gt;</span>
<span class="c1">// &lt;/div&gt;</span>
<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">composedPath</span><span class="p">());</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
<span class="c1">// [p, div, body, html, document, Window]</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">click</code>事件的最底层节点是<code class="language-plaintext highlighter-rouge">p</code>，向上依次是<code class="language-plaintext highlighter-rouge">div</code>、<code class="language-plaintext highlighter-rouge">body</code>、<code class="language-plaintext highlighter-rouge">html</code>、<code class="language-plaintext highlighter-rouge">document</code>、<code class="language-plaintext highlighter-rouge">Window</code>。</p>

<h2 id="四鼠标事件">四、鼠标事件</h2>

<h3 id="1鼠标事件的种类">1、鼠标事件的种类</h3>

<p>鼠标事件指与鼠标相关的事件，继承了<code class="language-plaintext highlighter-rouge">MouseEvent</code>接口。具体的事件主要有以下一些。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">click</code>：按下鼠标（通常是按下主按钮）时触发。<strong>【单击】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">dblclick</code>：在同一个元素上双击鼠标时触发。<strong>【双击】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">mousedown</code>：按下鼠标键时触发。<strong>【按下】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">mouseup</code>：释放按下的鼠标键时触发。<strong>【抬起】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。<strong>【经过（多次）】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">mouseenter</code>：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。<strong>【进入（单次）】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">mouseover</code>：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。<strong>【进入+子节点】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">mouseleave</code>：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。<strong>【离开（单次）】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">mouseout</code>：鼠标离开一个节点时触发，离开父节点会触发这个事件（详见后文）。<strong>【离开+子节点】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。<strong>【右键】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code class="language-plaintext highlighter-rouge">WheelEvent</code>接口。<strong>【滚轮】</strong></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">click</code>事件指的是，用户在同一个位置先完成<code class="language-plaintext highlighter-rouge">mousedown</code>动作，再完成<code class="language-plaintext highlighter-rouge">mouseup</code>动作。因此，触发顺序是，<code class="language-plaintext highlighter-rouge">mousedown</code>首先触发，<code class="language-plaintext highlighter-rouge">mouseup</code>接着触发，<code class="language-plaintext highlighter-rouge">click</code>最后触发。</p>

<p><code class="language-plaintext highlighter-rouge">dblclick</code>事件则会在<code class="language-plaintext highlighter-rouge">mousedown</code>、<code class="language-plaintext highlighter-rouge">mouseup</code>、<code class="language-plaintext highlighter-rouge">click</code>之后触发。</p>

<p><code class="language-plaintext highlighter-rouge">mouseover</code>事件和<code class="language-plaintext highlighter-rouge">mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code class="language-plaintext highlighter-rouge">mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code class="language-plaintext highlighter-rouge">mouseover</code>事件会在子节点上触发多次。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* HTML 代码如下
 &lt;ul&gt;
   &lt;li&gt;item 1&lt;/li&gt;
   &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
 &lt;/ul&gt;
*/</span>

<span class="kd">var</span> <span class="nx">ul</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 进入 ul 节点以后，mouseenter 事件只会触发一次</span>
<span class="c1">// 以后只要鼠标在节点内移动，都不会再触发这个事件</span>
<span class="c1">// event.target 是 ul 节点</span>
<span class="nx">ul</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseenter</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">purple</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">500</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="c1">// 进入 ul 节点以后，只要在子节点上移动，mouseover 事件会触发多次</span>
<span class="c1">// event.target 是 li 节点</span>
<span class="nx">ul</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseover</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">orange</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">500</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，在父节点内部进入子节点，不会触发<code class="language-plaintext highlighter-rouge">mouseenter</code>事件，但是会触发<code class="language-plaintext highlighter-rouge">mouseover</code>事件。</p>

<p><code class="language-plaintext highlighter-rouge">mouseout</code>事件和<code class="language-plaintext highlighter-rouge">mouseleave</code>事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，<code class="language-plaintext highlighter-rouge">mouseleave</code>事件不会触发，而<code class="language-plaintext highlighter-rouge">mouseout</code>事件会触发。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* HTML 代码如下
 &lt;ul&gt;
   &lt;li&gt;item 1&lt;/li&gt;
   &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
 &lt;/ul&gt;
*/</span>

<span class="kd">var</span> <span class="nx">ul</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">ul</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 先进入 ul 节点，然后在节点内部移动，不会触发 mouseleave 事件</span>
<span class="c1">// 只有离开 ul 节点时，触发一次 mouseleave</span>
<span class="c1">// event.target 是 ul 节点</span>
<span class="nx">ul</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseleave</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">purple</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">500</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="c1">// 先进入 ul 节点，然后在节点内部移动，mouseout 事件会触发多次</span>
<span class="c1">// event.target 是 li 节点</span>
<span class="nx">ul</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseout</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">orange</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">500</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，在父节点内部离开子节点，不会触发<code class="language-plaintext highlighter-rouge">mouseleave</code>事件，但是会触发<code class="language-plaintext highlighter-rouge">mouseout</code>事件。</p>

<h3 id="2mouseevent-接口概述">2、MouseEvent 接口概述</h3>

<p><code class="language-plaintext highlighter-rouge">MouseEvent</code>接口代表<strong>所有鼠标事件所产生的对象都是<code class="language-plaintext highlighter-rouge">MouseEvent</code>实例</strong>。此外，<strong>滚轮事件和拖拉事件也是<code class="language-plaintext highlighter-rouge">MouseEvent</code>实例。</strong></p>

<p><code class="language-plaintext highlighter-rouge">MouseEvent</code>接口<strong>继承了<code class="language-plaintext highlighter-rouge">Event</code>接口</strong>，所以拥有<code class="language-plaintext highlighter-rouge">Event</code>的所有属性和方法。它还有自己的属性和方法。</p>

<p>浏览器<strong>原生提供一个<code class="language-plaintext highlighter-rouge">MouseEvent</code>构造函数</strong>，用于新建一个<code class="language-plaintext highlighter-rouge">MouseEvent</code>实例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MouseEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span><span class="c1">// 参数一，事件名称字符串；参数二，事件配置对象</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">MouseEvent</code>构造函数接受两个参数。第一个参数是字符串，表示<strong>事件名称</strong>；第二个参数是一个<strong>事件配置对象</strong>，该参数可选。除了<code class="language-plaintext highlighter-rouge">Event</code>接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">screenX</code>：数值，鼠标相对于<strong>屏幕</strong>的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
  <li><code class="language-plaintext highlighter-rouge">screenY</code>：数值，鼠标相对于<strong>屏幕</strong>的垂直位置（单位像素），其他与<code class="language-plaintext highlighter-rouge">screenX</code>相同。</li>
  <li><code class="language-plaintext highlighter-rouge">clientX</code>：数值，鼠标相对于<strong>程序窗口</strong>的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
  <li><code class="language-plaintext highlighter-rouge">clientY</code>：数值，鼠标相对于<strong>程序窗口</strong>的垂直位置（单位像素），其他与<code class="language-plaintext highlighter-rouge">clientX</code>相同。</li>
  <li><code class="language-plaintext highlighter-rouge">ctrlKey</code>：布尔值，是否同时按下了 Ctrl 键，默认值为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">shiftKey</code>：布尔值，是否同时按下了 Shift 键，默认值为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">altKey</code>：布尔值，是否同时按下 Alt 键，默认值为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">metaKey</code>：布尔值，是否同时按下 Meta 键（win键），默认值为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">button</code>：数值，表示按下了哪一个鼠标按键，默认值为<code class="language-plaintext highlighter-rouge">0</code>，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；<code class="language-plaintext highlighter-rouge">1</code>表示按下辅助键（通常是鼠标的中间键），<code class="language-plaintext highlighter-rouge">2</code>表示按下次要键（通常是鼠标的右键）。</li>
  <li><code class="language-plaintext highlighter-rouge">buttons</code>：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为<code class="language-plaintext highlighter-rouge">0</code>（没有按下任何键）。<code class="language-plaintext highlighter-rouge">1</code>（二进制<code class="language-plaintext highlighter-rouge">001</code>）表示按下主键（通常是左键），<code class="language-plaintext highlighter-rouge">2</code>（二进制<code class="language-plaintext highlighter-rouge">010</code>）表示按下次要键（通常是右键），<code class="language-plaintext highlighter-rouge">4</code>（二进制<code class="language-plaintext highlighter-rouge">100</code>）表示按下辅助键（通常是中间键）。因此，如果返回<code class="language-plaintext highlighter-rouge">3</code>（二进制<code class="language-plaintext highlighter-rouge">011</code>）就表示同时按下了左键和右键。</li>
  <li><code class="language-plaintext highlighter-rouge">relatedTarget</code>：节点对象，表示事件的相关节点，默认为<code class="language-plaintext highlighter-rouge">null</code>。<code class="language-plaintext highlighter-rouge">mouseenter</code>和<code class="language-plaintext highlighter-rouge">mouseover</code>事件时，表示鼠标刚刚离开的那个元素节点；<code class="language-plaintext highlighter-rouge">mouseout</code>和<code class="language-plaintext highlighter-rouge">mouseleave</code>事件时，表示鼠标正在进入的那个元素节点。</li>
</ul>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MouseEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">click2</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">bubbles</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="dl">'</span><span class="s1">cancelable</span><span class="dl">'</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">cb</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">checkbox</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">cb</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click2</span><span class="dl">'</span><span class="p">,</span><span class="kd">function</span><span class="p">(){</span> <span class="c1">// 绑定事件监听函数</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span> <span class="c1">// 被执行</span>
<span class="p">})</span>
<span class="nx">cb</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span><span class="c1">// 触发事件</span>
</code></pre></div></div>

<p>上面代码生成一个鼠标点击事件，并触发该事件。</p>

<h3 id="3mouseevent-接口的实例属性">3、MouseEvent 接口的实例属性</h3>

<h4 id="31-mouseeventaltkeymouseeventctrlkeymouseeventmetakeymouseeventshiftkey">3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</h4>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.altKey</code>、<code class="language-plaintext highlighter-rouge">MouseEvent.ctrlKey</code>、<code class="language-plaintext highlighter-rouge">MouseEvent.metaKey</code>、<code class="language-plaintext highlighter-rouge">MouseEvent.shiftKey</code>这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是<strong>只读</strong>属性。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">altKey</code>属性：Alt 键</li>
  <li><code class="language-plaintext highlighter-rouge">ctrlKey</code>属性：Ctrl 键</li>
  <li><code class="language-plaintext highlighter-rouge">metaKey</code>属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）</li>
  <li><code class="language-plaintext highlighter-rouge">shiftKey</code>属性：Shift 键</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;body onclick="showKey(event)"&gt;</span>
<span class="kd">function</span> <span class="nx">showKey</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ALT key pressed: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">altKey</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">CTRL key pressed: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ctrlKey</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">META key pressed: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">metaKey</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">SHIFT key pressed: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">shiftKey</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，点击网页会输出是否同时按下对应的键。</p>

<h4 id="32-mouseeventbutton-鼠标的哪个键mouseeventbuttons同时按哪些键">3.2 MouseEvent.button 鼠标的哪个键，MouseEvent.buttons同时按哪些键</h4>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.button</code>属性返回<strong>一个数值，表示事件发生时按下了鼠标的哪个键</strong>。该属性<strong>只读</strong>。</p>

<ul>
  <li>0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如<code class="language-plaintext highlighter-rouge">mousemove</code>事件）。</li>
  <li>1：按下辅助键（通常是中键或者滚轮键）。</li>
  <li>2：按下次键（通常是右键）。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;button onmouseup="whichButton(event)"&gt;点击&lt;/button&gt;</span>
<span class="kd">var</span> <span class="nx">whichButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">button</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Left button clicked.</span><span class="dl">'</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Middle button clicked.</span><span class="dl">'</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Right button clicked.</span><span class="dl">'</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Unexpected code: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">button</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.buttons</code>属性返回一个<strong>三个比特位的值</strong>，表示<strong>同时按下了哪些键</strong>。它<strong>用来处理同时按下多个鼠标键的情况</strong>。该属性<strong>只读</strong>。</p>

<ul>
  <li>1：二进制为<code class="language-plaintext highlighter-rouge">001</code>（十进制的1），表示按下左键。</li>
  <li>2：二进制为<code class="language-plaintext highlighter-rouge">010</code>（十进制的2），表示按下右键。</li>
  <li>4：二进制为<code class="language-plaintext highlighter-rouge">100</code>（十进制的4），表示按下中键或滚轮键。</li>
</ul>

<p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回3（二进制为011）。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mousemove</span><span class="dl">'</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span> <span class="c1">// 注意，用click时一直都是0</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">buttons</span><span class="p">)</span>
<span class="p">})</span>
<span class="c1">// 未按下任何键时是 0</span>
<span class="c1">// 按下左键 1  （001）</span>
<span class="c1">// 按下右键 2  （010）</span>
<span class="c1">// 按下中键 4  （100）</span>

<span class="c1">// 按下左键和右键 3  （011）</span>
<span class="c1">// 按下左键和中键 5  （101）</span>
<span class="c1">// 按下右键和中键 6  （110）</span>
<span class="c1">// 按下左、中、右键 7  （111）</span>
</code></pre></div></div>

<h4 id="33-mouseeventclientx-相对浏览器x坐标mouseeventclienty-相对浏览器y坐标">3.3 MouseEvent.clientX 相对浏览器X坐标，MouseEvent.clientY 相对浏览器Y坐标</h4>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.clientX</code>属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素），<code class="language-plaintext highlighter-rouge">MouseEvent.clientY</code>属性返回垂直坐标。这两个属性都是<strong>只读</strong>属性。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码为</span>
<span class="c1">// &lt;body onmousedown="showCoords(event)"&gt;</span>
<span class="kd">function</span> <span class="nx">showCoords</span><span class="p">(</span><span class="nx">evt</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="dl">'</span><span class="s1">clientX value: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">clientX</span> <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="dl">'</span> <span class="o">+</span>
    <span class="dl">'</span><span class="s1">clientY value: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">clientY</span> <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="dl">'</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这两个属性还分别有一个<strong>别名<code class="language-plaintext highlighter-rouge">MouseEvent.x</code>和<code class="language-plaintext highlighter-rouge">MouseEvent.y</code></strong>。</p>

<h4 id="34-mouseeventmovementx-上一个鼠标经过事件的x距离mouseeventmovementy-上一个鼠标经过事件的y距离">3.4 MouseEvent.movementX 上一个鼠标经过事件的X距离，MouseEvent.movementY 上一个鼠标经过事件的Y距离</h4>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.movementX</code>属性返回当前位置与上一个<code class="language-plaintext highlighter-rouge">mousemove</code>事件之间的水平距离（单位像素）。数值上，它等于下面的计算公式。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">currentEvent</span><span class="p">.</span><span class="nx">movementX</span> <span class="o">=</span> <span class="nx">currentEvent</span><span class="p">.</span><span class="nx">screenX</span> <span class="o">-</span> <span class="nx">previousEvent</span><span class="p">.</span><span class="nx">screenX</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.movementY</code>属性返回当前位置与上一个<code class="language-plaintext highlighter-rouge">mousemove</code>事件之间的垂直距离（单位像素）。数值上，它等于下面的计算公式。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">currentEvent</span><span class="p">.</span><span class="nx">movementY</span> <span class="o">=</span> <span class="nx">currentEvent</span><span class="p">.</span><span class="nx">screenY</span> <span class="o">-</span> <span class="nx">previousEvent</span><span class="p">.</span><span class="nx">screenY</span><span class="err">。</span>
</code></pre></div></div>

<p>这两个属性都是<strong>只读</strong>属性。</p>

<h4 id="35-mouseeventscreenx-相对屏幕x坐标mouseeventscreeny-相对屏幕y坐标">3.5 MouseEvent.screenX 相对屏幕X坐标，MouseEvent.screenY 相对屏幕Y坐标</h4>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.screenX</code>属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），<code class="language-plaintext highlighter-rouge">MouseEvent.screenY</code>属性返回垂直坐标。这两个属性都是<strong>只读</strong>属性。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;body onmousedown="showCoords(event)"&gt;</span>
<span class="kd">function</span> <span class="nx">showCoords</span><span class="p">(</span><span class="nx">evt</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="dl">'</span><span class="s1">screenX value: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">screenX</span> <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">,</span>
    <span class="dl">'</span><span class="s1">screenY value: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">screenY</span> <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="dl">'</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="36-mouseeventoffsetx-偏移量xmouseeventoffsety-偏移量y">3.6 MouseEvent.offsetX 偏移量X，MouseEvent.offsetY 偏移量Y</h4>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.offsetX</code>属性返回鼠标位置与目标节点左侧的<code class="language-plaintext highlighter-rouge">padding</code>边缘的水平距离（单位像素），<code class="language-plaintext highlighter-rouge">MouseEvent.offsetY</code>属性返回与目标节点上方的<code class="language-plaintext highlighter-rouge">padding</code>边缘的垂直距离。这两个属性都是只读属性。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* HTML 代码如下
  &lt;style&gt;
    p {
      width: 100px;
      height: 100px;
      padding: 100px;
    }
  &lt;/style&gt;
  &lt;p&gt;Hello&lt;/p&gt;
*/</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">offsetX</span><span class="p">);</span> <span class="c1">// 包含padding</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">offsetY</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="kc">false</span>
<span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，鼠标如果在<code class="language-plaintext highlighter-rouge">p</code>元素的中心位置点击，会返回<code class="language-plaintext highlighter-rouge">150 150</code>。因此中心位置距离左侧和上方的<code class="language-plaintext highlighter-rouge">padding</code>边缘，等于<code class="language-plaintext highlighter-rouge">padding</code>的宽度（100像素）加上元素内容区域一半的宽度（50像素）。</p>

<h4 id="37-mouseeventpagex-文档x坐标mouseeventpagey-文档y坐标">3.7 MouseEvent.pageX 文档X坐标，MouseEvent.pageY 文档Y坐标</h4>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.pageX</code>属性返回鼠标位置与文档左侧边缘的距离（单位像素），<code class="language-plaintext highlighter-rouge">MouseEvent.pageY</code>属性返回与文档上侧边缘的距离（单位像素）。它们的<strong>返回值都包括文档不可见的部分</strong>。这两个属性都是<strong>只读</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* HTML 代码如下
  &lt;style&gt;
    body {
      height: 2000px;
    }
  &lt;/style&gt;
*/</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">pageX</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">pageY</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="kc">false</span>
<span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，页面高度为2000像素，会产生垂直滚动条。滚动到页面底部，点击鼠标输出的<code class="language-plaintext highlighter-rouge">pageY</code>值会接近2000。</p>

<h4 id="38-mouseeventrelatedtarget-事件的相关节点">3.8 MouseEvent.relatedTarget 事件的相关节点</h4>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.relatedTarget</code>属性<strong>返回事件的相关节点</strong>。对于那些没有相关节点的事件，该属性返回<code class="language-plaintext highlighter-rouge">null</code>。该属性<strong>只读</strong>。</p>

<p>下表列出不同事件的<code class="language-plaintext highlighter-rouge">target</code>属性值和<code class="language-plaintext highlighter-rouge">relatedTarget</code>属性值义。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">事件名称</th>
      <th style="text-align: left">target 属性</th>
      <th style="text-align: left">relatedTarget 属性</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">focusin</td>
      <td style="text-align: left">接受焦点的节点</td>
      <td style="text-align: left">丧失焦点的节点</td>
    </tr>
    <tr>
      <td style="text-align: left">focusout</td>
      <td style="text-align: left">丧失焦点的节点</td>
      <td style="text-align: left">接受焦点的节点</td>
    </tr>
    <tr>
      <td style="text-align: left">mouseenter</td>
      <td style="text-align: left">将要进入的节点</td>
      <td style="text-align: left">将要离开的节点</td>
    </tr>
    <tr>
      <td style="text-align: left">mouseleave</td>
      <td style="text-align: left">将要离开的节点</td>
      <td style="text-align: left">将要进入的节点</td>
    </tr>
    <tr>
      <td style="text-align: left">mouseout</td>
      <td style="text-align: left">将要离开的节点</td>
      <td style="text-align: left">将要进入的节点</td>
    </tr>
    <tr>
      <td style="text-align: left">mouseover</td>
      <td style="text-align: left">将要进入的节点</td>
      <td style="text-align: left">将要离开的节点</td>
    </tr>
    <tr>
      <td style="text-align: left">dragenter</td>
      <td style="text-align: left">将要进入的节点</td>
      <td style="text-align: left">将要离开的节点</td>
    </tr>
    <tr>
      <td style="text-align: left">dragexit</td>
      <td style="text-align: left">将要离开的节点</td>
      <td style="text-align: left">将要进入的节点</td>
    </tr>
  </tbody>
</table>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
  HTML 代码如下
  &lt;div id="outer" style="height:50px;width:50px;border-width:1px solid black;"&gt;
    &lt;div id="inner" style="height:25px;width:25px;border:1px solid black;"&gt;&lt;/div&gt;
  &lt;/div&gt;
*/</span>

<span class="kd">var</span> <span class="nx">inner</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">inner</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">inner</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseover</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">进入</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">id</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> 离开</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">relatedTarget</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">inner</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseenter</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">进入</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">id</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> 离开</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">relatedTarget</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">inner</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseout</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">离开</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">id</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> 进入</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">relatedTarget</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">inner</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">mouseleave</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">离开</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">id</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> 进入</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">relatedTarget</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 鼠标从 outer 进入inner，输出</span>
<span class="c1">// 进入inner 离开outer</span>
<span class="c1">// 进入inner 离开outer</span>

<span class="c1">// 鼠标从 inner进入 outer，输出</span>
<span class="c1">// 离开inner 进入outer</span>
<span class="c1">// 离开inner 进入outer</span>
</code></pre></div></div>

<h3 id="4mouseevent-接口的实例方法">4、MouseEvent 接口的实例方法</h3>

<h4 id="41-mouseeventgetmodifierstate-是否按下指定功能键">4.1 MouseEvent.getModifierState() 是否按下指定功能键</h4>

<p><code class="language-plaintext highlighter-rouge">MouseEvent.getModifierState</code>方法<strong>返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#Modifier_keys_on_Gecko">功能键</a>的字符串。</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">getModifierState</span><span class="p">(</span><span class="dl">'</span><span class="s1">CapsLock</span><span class="dl">'</span><span class="p">));</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面的代码可以了解用户是否按下了大写键。</p>

<h3 id="5wheelevent-接口-滚轮">5、WheelEvent 接口 （滚轮）</h3>

<h4 id="51-概述">5.1 概述</h4>

<p><strong>WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象</strong>。目前，鼠标滚轮相关的事件只有一个<code class="language-plaintext highlighter-rouge">wheel</code>事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p>

<p>浏览器原生提供<code class="language-plaintext highlighter-rouge">WheelEvent()</code>构造函数，用来生成<code class="language-plaintext highlighter-rouge">WheelEvent</code>实例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">wheelEvent</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WheelEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">WheelEvent()</code>构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是<code class="language-plaintext highlighter-rouge">wheel</code>。第二个参数是事件的配置对象。该对象的属性除了<code class="language-plaintext highlighter-rouge">Event</code>、<code class="language-plaintext highlighter-rouge">UIEvent</code>的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 0.0。</li>
  <li><code class="language-plaintext highlighter-rouge">deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 0.0。</li>
  <li><code class="language-plaintext highlighter-rouge">deltaZ</code>：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。</li>
  <li><code class="language-plaintext highlighter-rouge">deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。<code class="language-plaintext highlighter-rouge">0</code>表示滚动单位为像素，<code class="language-plaintext highlighter-rouge">1</code>表示单位为行，<code class="language-plaintext highlighter-rouge">2</code>表示单位为页，默认为<code class="language-plaintext highlighter-rouge">0</code>。</li>
</ul>

<h4 id="52-实例属性">5.2 实例属性</h4>

<p><code class="language-plaintext highlighter-rouge">WheelEvent</code>事件实例除了具有<code class="language-plaintext highlighter-rouge">Event</code>和<code class="language-plaintext highlighter-rouge">MouseEvent</code>的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p>

<p>下面的属性都是只读属性。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</li>
  <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</li>
  <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaZ</code>：数值，表示滚轮的 Z 轴滚动量。</li>
  <li><code class="language-plaintext highlighter-rouge">WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，<code class="language-plaintext highlighter-rouge">0</code>是像素，<code class="language-plaintext highlighter-rouge">1</code>是行，<code class="language-plaintext highlighter-rouge">2</code>是页。</li>
</ul>

<h2 id="五键盘事件">五、键盘事件</h2>

<h3 id="1键盘事件的种类">1、键盘事件的种类</h3>

<p>键盘事件由用户击打键盘触发，主要有<code class="language-plaintext highlighter-rouge">keydown</code>、<code class="language-plaintext highlighter-rouge">keypress</code>、<code class="language-plaintext highlighter-rouge">keyup</code>三个事件，它们都继承了<code class="language-plaintext highlighter-rouge">KeyboardEvent</code>接口。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">keydown</code>：按下键盘时触发。<strong>【按下】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code class="language-plaintext highlighter-rouge">keydown</code>事件，再触发这个事件。<strong>【按下有值的键】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">keyup</code>：松开键盘时触发该事件。<strong>【松开】</strong></li>
</ul>

<p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p>

<ol>
  <li>keydown</li>
  <li>keypress</li>
  <li>keydown</li>
  <li>keypress</li>
  <li>…（重复以上过程）</li>
  <li>keyup</li>
</ol>

<h3 id="2keyboardevent-接口概述">2、KeyboardEvent 接口概述</h3>

<p><code class="language-plaintext highlighter-rouge">KeyboardEvent</code>接口用来描述用户与键盘的互动。这个接口<strong>继承了<code class="language-plaintext highlighter-rouge">Event</code>接口</strong>，并且定义了自己的实例属性和实例方法。</p>

<p>浏览器原生提供<code class="language-plaintext highlighter-rouge">KeyboardEvent</code>构造函数，用来新建键盘事件的实例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nx">KeyboardEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="c1">// 参数一，事件类型；参数二，事件配置对象</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示<strong>事件类型</strong>；第二个参数是一个<strong>事件配置对象</strong>，该参数可选。除了<code class="language-plaintext highlighter-rouge">Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">key</code>：字符串，当前按下的键，默认为空字符串。<strong>【键名】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。<strong>【键码】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">location</code>：整数，当前按下的键的位置，默认为<code class="language-plaintext highlighter-rouge">0</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">altKey</code>：布尔值，是否按下 Alt 键，默认为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">metaKey</code>：布尔值，是否按下 Meta 键，默认为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">repeat</code>：布尔值，是否重复按键，默认为<code class="language-plaintext highlighter-rouge">false</code>。</li>
</ul>

<h3 id="3keyboardevent-的实例属性">3、KeyboardEvent 的实例属性</h3>

<h4 id="31-keyboardeventaltkeykeyboardeventctrlkeykeyboardeventmetakeykeyboardeventshiftkey-是否按下对应键布尔值">3.1 KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey 【是否按下对应键，布尔值】</h4>

<p>以下属性都是<strong>只读</strong>属性，返回一个布尔值，表示是否按下对应的键。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.altKey</code>：是否按下 Alt 键</li>
  <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.ctrlKey</code>：是否按下 Ctrl 键</li>
  <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.metaKey</code>：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）</li>
  <li><code class="language-plaintext highlighter-rouge">KeyboardEvent.shiftKey</code>：是否按下 Shift 键</li>
</ul>

<p>下面是一个示例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">showChar</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ALT: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">altKey</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">CTRL: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ctrlKey</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Meta: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">metaKey</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Shift: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">shiftKey</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">keydown</span><span class="dl">'</span><span class="p">,</span> <span class="nx">showChar</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="32-keyboardeventcode-键码">3.2 KeyboardEvent.code 键码</h4>

<p><code class="language-plaintext highlighter-rouge">KeyboardEvent.code</code>属性<strong>返回一个字符串，表示当前按下的键的字符串形式</strong>。该属性<strong>只读</strong>。</p>

<p>下面是一些常用键的字符串形式，其他键请查<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code#Code_values">文档</a>。</p>

<ul>
  <li>数字键0 - 9：返回<code class="language-plaintext highlighter-rouge">digital0</code> - <code class="language-plaintext highlighter-rouge">digital9</code></li>
  <li>字母键A - z：返回<code class="language-plaintext highlighter-rouge">KeyA</code> - <code class="language-plaintext highlighter-rouge">KeyZ</code></li>
  <li>功能键F1 - F12：返回 <code class="language-plaintext highlighter-rouge">F1</code> - <code class="language-plaintext highlighter-rouge">F12</code></li>
  <li>方向键：返回<code class="language-plaintext highlighter-rouge">ArrowDown</code>、<code class="language-plaintext highlighter-rouge">ArrowUp</code>、<code class="language-plaintext highlighter-rouge">ArrowLeft</code>、<code class="language-plaintext highlighter-rouge">ArrowRight</code></li>
  <li>Alt 键：返回<code class="language-plaintext highlighter-rouge">AltLeft</code>或<code class="language-plaintext highlighter-rouge">AltRight</code></li>
  <li>Shift 键：返回<code class="language-plaintext highlighter-rouge">ShiftLeft</code>或<code class="language-plaintext highlighter-rouge">ShiftRight</code></li>
  <li>Ctrl 键：返回<code class="language-plaintext highlighter-rouge">ControlLeft</code>或<code class="language-plaintext highlighter-rouge">ControlRight</code></li>
</ul>

<h4 id="33-keyboardeventkey-键名">3.3 KeyboardEvent.key 键名</h4>

<p><code class="language-plaintext highlighter-rouge">KeyboardEvent.key</code>属性<strong>返回一个字符串，表示按下的键名</strong>。该属性<strong>只读</strong>。</p>

<p>如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。</p>

<p>如果按下的键代表不可打印的特殊字符，则返回预定义的键值，比如 Backspace，Tab，Enter，Shift，Control，Alt，CapsLock，Esc，Spacebar，PageUp，PageDown，End，Home，Left，Right，Up，Down，PrintScreen，Insert，Del，Win，F1～F12，NumLock，Scroll 等。</p>

<p>如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下 Ctrl + a，则返回<code class="language-plaintext highlighter-rouge">a</code>；按下 Shift + a，则返回大写的<code class="language-plaintext highlighter-rouge">A</code>。</p>

<p>如果无法识别键名，返回字符串<code class="language-plaintext highlighter-rouge">Unidentified</code>。</p>

<h4 id="34-keyboardeventlocation-键处于哪个位置整数">3.4 KeyboardEvent.location 键处于哪个位置，整数</h4>

<p><code class="language-plaintext highlighter-rouge">KeyboardEvent.location</code>属性<strong>返回一个整数，表示按下的键处在键盘的哪一个区域</strong>。它可能取以下值。</p>

<ul>
  <li>
    <p>0：处在键盘的主区域，或者无法判断处于哪一个区域。</p>
  </li>
  <li>
    <p>1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</p>
  </li>
  <li>
    <p>2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</p>
  </li>
  <li>
    <p>3：处在数字小键盘。</p>
  </li>
</ul>

<h4 id="35-keyboardeventrepeat-是否长按">3.5 KeyboardEvent.repeat 是否长按</h4>

<p><code class="language-plaintext highlighter-rouge">KeyboardEvent.repeat</code>返回一个<strong>布尔值，代表该键是否被按着不放</strong>，以便判断是否重复这个键，即浏览器会持续触发<code class="language-plaintext highlighter-rouge">keydown</code>和<code class="language-plaintext highlighter-rouge">keypress</code>事件，直到用户松开手为止。</p>

<h3 id="4keyboardevent-的实例方法">4、KeyboardEvent 的实例方法</h3>

<h4 id="41-keyboardeventgetmodifierstate-是否按下指定功能键">4.1 KeyboardEvent.getModifierState() 是否按下指定功能键</h4>

<p><code class="language-plaintext highlighter-rouge">KeyboardEvent.getModifierState()</code>方法返回一个<strong>布尔值，表示是否按下或激活指定的功能键</strong>。它的常用参数如下。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Alt</code>：Alt 键</li>
  <li><code class="language-plaintext highlighter-rouge">CapsLock</code>：大写锁定键</li>
  <li><code class="language-plaintext highlighter-rouge">Control</code>：Ctrl 键</li>
  <li><code class="language-plaintext highlighter-rouge">Meta</code>：Meta 键</li>
  <li><code class="language-plaintext highlighter-rouge">NumLock</code>：数字键盘开关键</li>
  <li><code class="language-plaintext highlighter-rouge">Shift</code>：Shift 键</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">getModifierState</span><span class="p">(</span><span class="dl">'</span><span class="s1">Control</span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">getModifierState</span><span class="p">(</span><span class="dl">'</span><span class="s1">Alt</span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">getModifierState</span><span class="p">(</span><span class="dl">'</span><span class="s1">Meta</span><span class="dl">'</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码表示，只要<code class="language-plaintext highlighter-rouge">Control</code>、<code class="language-plaintext highlighter-rouge">Alt</code>、<code class="language-plaintext highlighter-rouge">Meta</code>里面，同时按下任意两个或两个以上的键就返回。</p>

<h2 id="六进度事件">六、进度事件</h2>

<h3 id="1进度事件的种类">1、进度事件的种类</h3>

<p><strong>进度事件用来描述资源加载的进度</strong>，主要由 AJAX 请求、<code class="language-plaintext highlighter-rouge">  &lt;img&gt;  </code>、<code class="language-plaintext highlighter-rouge">  &lt;audio&gt;  </code>、<code class="language-plaintext highlighter-rouge">  &lt;video&gt;  </code>、<code class="language-plaintext highlighter-rouge">  &lt;style&gt;  </code>、<code class="language-plaintext highlighter-rouge"> &lt;link&gt; </code>等外部资源的加载触发，继承了<code class="language-plaintext highlighter-rouge">ProgressEvent</code>接口。它主要包含以下几种<strong>事件</strong>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">abort</code>：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。<strong>【中止加载】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">error</code>：由于错误导致外部资源无法加载时触发。<strong>【加载错误】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">load</code>：外部资源加载成功时触发。<strong>【加载成功】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">loadstart</code>：外部资源开始加载时触发。<strong>【开始加载】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">loadend</code>：外部资源停止加载时触发，发生顺序排在<code class="language-plaintext highlighter-rouge">error</code>、<code class="language-plaintext highlighter-rouge">abort</code>、<code class="language-plaintext highlighter-rouge">load</code>等事件的后面。<strong>【停止加载】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">progress</code>：外部资源加载过程中不断触发。<strong>【加载中，不断触发】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">timeout</code>：加载超时时触发。<strong>【加载超时】</strong></li>
</ul>

<p>注意，除了资源下载，<strong>文件上传也存在这些事件</strong>。</p>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">image</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 加载成功</span>
  <span class="nx">image</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">finished</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">image</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 加载出错</span>
  <span class="nx">image</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">none</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码在图片元素加载完成后，为图片元素添加一个<code class="language-plaintext highlighter-rouge">finished</code>的 Class。如果加载失败，就把图片元素的样式设置为不显示。</p>

<p>有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能<code class="language-plaintext highlighter-rouge">load</code>和<code class="language-plaintext highlighter-rouge">error</code>事件的监听函数根本不会执行。所以，比较可靠的方式，是用<code class="language-plaintext highlighter-rouge">complete</code>属性先判断一下是否加载完成。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">loaded</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">complete</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 是否加载完成</span>
  <span class="nx">loaded</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">image</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="nx">loaded</span><span class="p">);</span> <span class="c1">// 加载成功事件</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由于 DOM 的元素节点没有提供是否加载错误的属性，所以<code class="language-plaintext highlighter-rouge">error</code>事件的监听函数最好放在<code class="language-plaintext highlighter-rouge">  &lt;img&gt;  </code>元素的 HTML 代码中，这样才能保证发生加载错误时百分之百会执行。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"/wrong/url"</span> <span class="na">onerror=</span><span class="s">"this.style.display='none';"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">loadend</code>事件的监听函数，可以用来取代<code class="language-plaintext highlighter-rouge">abort</code>事件、<code class="language-plaintext highlighter-rouge">load</code>事件、<code class="language-plaintext highlighter-rouge">error</code>事件的监听函数，因为它总是在这些事件之后发生。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">req</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">loadend</span><span class="dl">'</span><span class="p">,</span> <span class="nx">loadEnd</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">loadEnd</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">传输结束，成功失败未知</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">loadend</code>事件本身不提供关于进度结束的原因，但可以用它来做所有加载结束场景都需要做的一些操作。</p>

<p>另外，<code class="language-plaintext highlighter-rouge">error</code>事件有一个特殊的性质，就是不会冒泡。所以，子元素的<code class="language-plaintext highlighter-rouge">error</code>事件，不会触发父元素的<code class="language-plaintext highlighter-rouge">error</code>事件监听函数。</p>

<h3 id="2progressevent-接口">2、ProgressEvent 接口</h3>

<h4 id="21-概述">2.1 概述</h4>

<p><code class="language-plaintext highlighter-rouge">ProgressEvent</code>接口主要用来描述外部资源加载的进度，比如 AJAX 加载、<code class="language-plaintext highlighter-rouge">  &lt;img&gt;  </code>、<code class="language-plaintext highlighter-rouge">  &lt;video&gt;  </code>、<code class="language-plaintext highlighter-rouge">  &lt;style&gt;  </code>、<code class="language-plaintext highlighter-rouge"> &lt;link&gt; </code>等外部资源加载。进度相关的事件都继承了这个接口。<strong>这个接口继承了Event接口。</strong></p>

<p>浏览器原生提供了<code class="language-plaintext highlighter-rouge">ProgressEvent()</code>构造函数，用来生成事件实例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nx">ProgressEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="c1">// 参数一，事件类型；参数二，配置对象</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ProgressEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的类型，这个参数是必须的。第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用<code class="language-plaintext highlighter-rouge">Event</code>接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lengthComputable</code>：布尔值，表示加载的<strong>总量是否可以计算</strong>，默认是<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">loaded</code>：整数，表示<strong>已经加载的量</strong>，默认是<code class="language-plaintext highlighter-rouge">0</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">total</code>：整数，表示<strong>需要加载的总量</strong>，默认是<code class="language-plaintext highlighter-rouge">0</code>。</li>
</ul>

<h4 id="22-progressevent的实例属性">2.2 ProgressEvent的实例属性。</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ProgressEvent.lengthComputable</code> <strong>总量是否可以计算</strong></li>
  <li><code class="language-plaintext highlighter-rouge">ProgressEvent.loaded</code> <strong>已加载的量</strong></li>
  <li><code class="language-plaintext highlighter-rouge">ProgressEvent.total </code> <strong>需要加载的总量</strong></li>
</ul>

<p>如果<code class="language-plaintext highlighter-rouge">ProgressEvent.lengthComputable</code>为<code class="language-plaintext highlighter-rouge">false</code>，<code class="language-plaintext highlighter-rouge">ProgressEvent.total</code>实际上是没有意义的。</p>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ProgressEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">lengthComputable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">loaded</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="na">total</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
<span class="p">});</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">已经加载：</span><span class="dl">'</span> <span class="o">+</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">loaded</span> <span class="o">/</span> <span class="nx">e</span><span class="p">.</span><span class="nx">total</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">%</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
<span class="c1">// 已经加载：30%</span>
</code></pre></div></div>

<p>上面代码先构造一个<code class="language-plaintext highlighter-rouge">load</code>事件，抛出后被监听函数捕捉到。</p>

<p>下面是一个实际的例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">progress</span><span class="dl">'</span><span class="p">,</span> <span class="nx">updateProgress</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// 加载中</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="nx">transferComplete</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// 加载成功</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="nx">transferFailed</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// 加载错误</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">abort</span><span class="dl">'</span><span class="p">,</span> <span class="nx">transferCanceled</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// 中止加载</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">updateProgress</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 加载中</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">lengthComputable</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 是否可以计算总量</span>
    <span class="kd">var</span> <span class="nx">percentComplete</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">loaded</span> <span class="o">/</span> <span class="nx">e</span><span class="p">.</span><span class="nx">total</span><span class="p">;</span> <span class="c1">// 加载进度计算</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">不能计算进度</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">transferComplete</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 加载成功</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">传输结束</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">transferFailed</span><span class="p">(</span><span class="nx">evt</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 加载错误</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">传输过程中发生错误</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">transferCanceled</span><span class="p">(</span><span class="nx">evt</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 中止加载</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">用户取消了传输</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面是下载过程的进度事件，还存在<strong>上传过程的进度事件</strong>。这时所有监听函数都要放在<code class="language-plaintext highlighter-rouge">XMLHttpRequest.upload</code>对象上面。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">upload</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">progress</span><span class="dl">'</span><span class="p">,</span> <span class="nx">updateProgress</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">upload</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="nx">transferComplete</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">upload</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="nx">transferFailed</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">upload</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">abort</span><span class="dl">'</span><span class="p">,</span> <span class="nx">transferCanceled</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="七表单事件">七、表单事件</h2>

<h3 id="1表单事件的种类">1、表单事件的种类</h3>

<h4 id="11-input-事件-值发生变化触发会连续">1.1 input 事件 （值发生变化触发，会连续）</h4>

<p><code class="language-plaintext highlighter-rouge">input</code>事件当<code class="language-plaintext highlighter-rouge"> &lt;input&gt; </code>、<code class="language-plaintext highlighter-rouge"> &lt;select&gt; </code>、<code class="language-plaintext highlighter-rouge"> &lt;textarea&gt; </code>的<strong>值发生变化时触发</strong>。对于复选框（<code class="language-plaintext highlighter-rouge"> &lt;input type=checkbox&gt; </code>）或单选框（<code class="language-plaintext highlighter-rouge"> &lt;input type=radio&gt; </code>），用户改变选项时，也会触发这个事件。另外，对于打开<code class="language-plaintext highlighter-rouge">contenteditable</code>属性的元素，只要值发生变化，也会触发<code class="language-plaintext highlighter-rouge">input</code>事件。</p>

<p><code class="language-plaintext highlighter-rouge">input</code>事件的一个特点，就是<strong>会连续触发</strong>，比如<strong>用户每按下一次按键，就会触发一次<code class="language-plaintext highlighter-rouge">input</code>事件</strong>。</p>

<p><code class="language-plaintext highlighter-rouge">input</code>事件对象<strong>继承了<code class="language-plaintext highlighter-rouge">InputEvent</code>接口</strong>。</p>

<p>该事件跟<code class="language-plaintext highlighter-rouge">change</code>事件很像，不同之处在于<strong><code class="language-plaintext highlighter-rouge">input</code>事件在元素的值发生变化后立即发生</strong>，<strong>而<code class="language-plaintext highlighter-rouge">change</code>在元素失去焦点时发生</strong>，而内容此时可能已经变化多次。也就是说，如果有连续变化，<strong><code class="language-plaintext highlighter-rouge">input</code>事件会触发多次，而<code class="language-plaintext highlighter-rouge">change</code>事件只在失去焦点时触发一次。</strong></p>

<p>下面是<code class="language-plaintext highlighter-rouge"> &lt;select&gt; </code>元素的例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* HTML 代码如下
&lt;select id="mySelect"&gt;
  &lt;option value="1"&gt;1&lt;/option&gt;
  &lt;option value="2"&gt;2&lt;/option&gt;
  &lt;option value="3"&gt;3&lt;/option&gt;
&lt;/select&gt;
*/</span>

<span class="kd">function</span> <span class="nx">inputHandler</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">mySelect</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">#mySelect</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">mySelect</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">input</span><span class="dl">'</span><span class="p">,</span> <span class="nx">inputHandler</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，改变下拉框选项时，会触发<code class="language-plaintext highlighter-rouge">input</code>事件，从而执行回调函数<code class="language-plaintext highlighter-rouge">inputHandler</code>。</p>

<h4 id="12-select-事件-选中文本时触发">1.2 select 事件 （选中文本时触发）</h4>

<p><code class="language-plaintext highlighter-rouge">select</code>事件当在<code class="language-plaintext highlighter-rouge"> &lt;input&gt; </code>、<code class="language-plaintext highlighter-rouge"> &lt;textarea&gt; </code>里面<strong>选中文本时触发</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input id="test" type="text" value="Select me!" /&gt;</span>

<span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">elem</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">select</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span> <span class="c1">// "select" 事件类型</span>

  <span class="kd">var</span> <span class="nx">_target</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 文本框的全部值</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_target</span><span class="p">.</span><span class="nx">selectionDirection</span><span class="p">);</span> <span class="c1">// 选择的方向：'forward'正向、'backward'反向</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_target</span><span class="p">.</span><span class="nx">selectionStart</span><span class="p">);</span> <span class="c1">// 开始选择的索引</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_target</span><span class="p">.</span><span class="nx">selectionEnd</span><span class="p">);</span> <span class="c1">// 结束选择的索引</span>
  <span class="c1">// 注意：开始和结束索引是不分选择方向的，开始的索引一直是靠前的</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_target</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">_target</span><span class="p">.</span><span class="nx">selectionStart</span><span class="p">,</span> <span class="nx">_target</span><span class="p">.</span><span class="nx">selectionEnd</span><span class="p">))</span> <span class="c1">// 选中的那部分字符串</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>选中的文本可以通过<code class="language-plaintext highlighter-rouge">event.target</code>元素的<code class="language-plaintext highlighter-rouge">selectionDirection</code>、<code class="language-plaintext highlighter-rouge">selectionEnd</code>、<code class="language-plaintext highlighter-rouge">selectionStart</code>和<code class="language-plaintext highlighter-rouge">value</code>属性拿到。</p>

<h4 id="13-change-事件-值发生变化时触发单次">1.3 change 事件 （值发生变化时触发，单次）</h4>

<p><code class="language-plaintext highlighter-rouge">change</code>事件当<code class="language-plaintext highlighter-rouge"> &lt;input&gt; </code>、<code class="language-plaintext highlighter-rouge"> &lt;select&gt; </code>、<code class="language-plaintext highlighter-rouge"> &lt;textarea&gt; </code>的<strong>值发生变化时触发</strong>。它与<code class="language-plaintext highlighter-rouge">input</code>事件的最大不同，就是<strong>不会连续触发，只有当全部修改完成时才会触发</strong>，另一方面<code class="language-plaintext highlighter-rouge">input</code>事件必然伴随<code class="language-plaintext highlighter-rouge">change</code>事件。具体来说，分成以下几种情况。</p>

<ul>
  <li>激活单选框（radio）或复选框（checkbox）时触发。</li>
  <li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li>
  <li>当文本框或<code class="language-plaintext highlighter-rouge"> &lt;textarea&gt; </code>元素的值发生改变，并且丧失焦点时触发。</li>
</ul>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;select size="1" onchange="changeEventHandler(event);"&gt;</span>
<span class="c1">//   &lt;option&gt;chocolate&lt;/option&gt;</span>
<span class="c1">//   &lt;option&gt;strawberry&lt;/option&gt;</span>
<span class="c1">//   &lt;option&gt;vanilla&lt;/option&gt;</span>
<span class="c1">// &lt;/select&gt;</span>

<span class="kd">function</span> <span class="nx">changeEventHandler</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果比较一下上面<code class="language-plaintext highlighter-rouge">input</code>事件的例子，你会发现对于<code class="language-plaintext highlighter-rouge"> &lt;select&gt; </code>元素来说，<code class="language-plaintext highlighter-rouge">input</code>和<code class="language-plaintext highlighter-rouge">change</code>事件基本是等价的。</p>

<h4 id="14-invalid-事件-表单提交不满足条件触发">1.4 invalid 事件 （表单提交不满足条件触发）</h4>

<p><strong>用户提交表单时，如果表单元素的值不满足校验条件，就会触发<code class="language-plaintext highlighter-rouge">invalid</code>事件。</strong></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">required</span> <span class="na">oninvalid=</span><span class="s">"console.log('invalid input')"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">"submit"</span><span class="nt">&gt;</span>提交<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</code></pre></div></div>

<p>上面代码中，输入框是必填的。如果不填，用户点击按钮提交时，就会触发输入框的<code class="language-plaintext highlighter-rouge">invalid</code>事件，导致提交被取消。</p>

<h4 id="15-reset-事件重置submit-事件提交">1.5 reset 事件（重置），submit 事件（提交）</h4>

<p><code class="language-plaintext highlighter-rouge">reset</code>事件当<strong>表单重置（所有表单成员变回默认值）时触发。</strong></p>

<p><code class="language-plaintext highlighter-rouge">submit</code>事件当<strong>表单数据向服务器提交时触发</strong>。</p>

<p>注意，<strong>这两个事件发生在表单对象<code class="language-plaintext highlighter-rouge"> &lt;form&gt; </code>上，而不是发生在表单的成员上</strong>，因为提交的是表单，而不是表单成员。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">onreset=</span><span class="s">"console.log('触发了重置事件')"</span> <span class="na">onsubmit=</span><span class="s">"console.log('触发了提交事件')"</span> <span class="na">name=</span><span class="s">"input"</span> <span class="na">action=</span><span class="s">"html_form_action.php"</span> <span class="na">method=</span><span class="s">"get"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"lname"</span> <span class="na">value=</span><span class="s">"Duck"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">"reset"</span><span class="nt">&gt;</span>重置<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">"submit"</span><span class="nt">&gt;</span>提交<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</code></pre></div></div>

<h3 id="2inputevent-接口input事件的实例">2、InputEvent 接口（input事件的实例）</h3>

<p><strong><code class="language-plaintext highlighter-rouge">InputEvent</code>接口主要用来描述<code class="language-plaintext highlighter-rouge">input</code>事件的实例</strong>。该接口<strong>继承了<code class="language-plaintext highlighter-rouge">Event</code>接口</strong>，还定义了一些自己的实例属性和实例方法。</p>

<p>浏览器原生提供<code class="language-plaintext highlighter-rouge">InputEvent()</code>构造函数，用来生成实例对象。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nx">InputEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="c1">// 参数一，事件名称；参数二，配置对象</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">InputEvent</code>构造函数可以接受两个参数。第一个参数是字符串，表示<strong>事件名称</strong>，该参数是必需的。第二个参数是一个<strong>配置对象</strong>，用来设置事件实例的属性，该参数是可选的。配置对象的字段除了<code class="language-plaintext highlighter-rouge">Event</code>构造函数的配置属性，还可以设置下面的字段，这些字段都是可选的。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inputType</code>：字符串，表示<strong>发生变更的类型</strong>（详见下文）。</li>
  <li><code class="language-plaintext highlighter-rouge">data</code>：字符串，表示<strong>插入的字符串</strong>。如果没有插入的字符串（比如删除操作），则返回<code class="language-plaintext highlighter-rouge">null</code>或空字符串。</li>
  <li><code class="language-plaintext highlighter-rouge">dataTransfer</code>：返回一个 <strong>DataTransfer 对象实例，该属性通常只在输入框接受富文本输入时有效</strong>。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">InputEvent</code>的实例属性主要就是上面三个属性，这三个实例属性都是<strong>只读的</strong>。</p>

<h4 id="1inputeventdata-变动的那部分内容">（1）InputEvent.data 变动的那部分内容</h4>

<p><code class="language-plaintext highlighter-rouge">InputEvent.data</code>属性返回一个字符串，表示<strong>变动的内容</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;input type="text" id="myInput"&gt;</span>
<span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myInput</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">input</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">input</span><span class="dl">'</span><span class="p">,</span> <span class="nx">myFunction</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">myFunction</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，如果手动在输入框里面输入<code class="language-plaintext highlighter-rouge">abc</code>，控制台会先输出<code class="language-plaintext highlighter-rouge">a</code>，再在下一行输出<code class="language-plaintext highlighter-rouge">b</code>，再在下一行输出<code class="language-plaintext highlighter-rouge">c</code>。然后选中<code class="language-plaintext highlighter-rouge">abc</code>，一次性将它们删除，控制台会输出<code class="language-plaintext highlighter-rouge">null</code>或一个空字符串。</p>

<h4 id="2inputeventinputtype-变更类型">（2）InputEvent.inputType 变更类型</h4>

<p><code class="language-plaintext highlighter-rouge">InputEvent.inputType</code>属性返回一个字符串，表示字符串<strong>发生变更的类型</strong>。</p>

<p>对于常见情况，Chrome 浏览器的返回值如下。完整列表可以参考<a href="https://w3c.github.io/input-events/index.html#dom-inputevent-inputtype">文档</a>。</p>

<ul>
  <li>手动插入文本：<code class="language-plaintext highlighter-rouge">insertText</code></li>
  <li>粘贴插入文本：<code class="language-plaintext highlighter-rouge">insertFromPaste</code></li>
  <li>向后删除：<code class="language-plaintext highlighter-rouge">deleteContentBackward</code></li>
  <li>向前删除：<code class="language-plaintext highlighter-rouge">deleteContentForward</code></li>
</ul>

<h4 id="3inputeventdatatransfer">（3）InputEvent.dataTransfer</h4>

<p><code class="language-plaintext highlighter-rouge">InputEvent.dataTransfer</code>属性<strong>返回一个 DataTransfer 实例。该属性只在文本框接受粘贴内容（insertFromPaste）或拖拽内容（<code class="language-plaintext highlighter-rouge">insertFromDrop</code>）时才有效</strong>。</p>

<h2 id="八触摸事件">八、触摸事件</h2>

<h3 id="1触摸操作概述">1、触摸操作概述</h3>

<p>浏览器的触摸 API 由三个部分组成。</p>

<ul>
  <li>Touch：一个触摸点的实例</li>
  <li>TouchList：多个触摸点集合的实例</li>
  <li>TouchEvent：触摸引发的事件实例</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Touch</code>接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括<strong>位置、大小、形状、压力、目标元素等属性</strong>。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code class="language-plaintext highlighter-rouge">TouchList</code>接口的实例对象表示。<code class="language-plaintext highlighter-rouge">TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p>

<p>很多时候，<strong>触摸事件和鼠标事件同时触发</strong>，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，<strong>可以用<code class="language-plaintext highlighter-rouge">event.preventDefault</code>方法阻止发出鼠标事件</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">TouchEvent</span> <span class="p">{</span><span class="nl">isTrusted</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">touches</span><span class="p">:</span> <span class="nx">TouchList</span><span class="p">,</span> <span class="nx">targetTouches</span><span class="p">:</span> <span class="nx">TouchList</span><span class="p">,</span> <span class="nx">changedTouches</span><span class="p">:</span> <span class="nx">TouchList</span><span class="p">,</span> <span class="nx">altKey</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="err">…</span><span class="p">}</span> <span class="c1">// TouchEvent接口 ，继承Event接口属性和方法</span>
    <span class="nl">altKey</span><span class="p">:</span> <span class="kc">false</span>
    <span class="nx">bubbles</span><span class="p">:</span> <span class="kc">true</span>
    <span class="nx">cancelBubble</span><span class="p">:</span> <span class="kc">false</span>
    <span class="nx">cancelable</span><span class="p">:</span> <span class="kc">false</span>
    <span class="nx">changedTouches</span><span class="p">:</span> <span class="nx">TouchList</span> <span class="c1">// TouchList 接口 （所有触摸点集合）</span>
            <span class="mi">0</span><span class="p">:</span> <span class="nx">Touch</span> <span class="c1">// Touch 接口 （单个触摸点）</span>
                <span class="nx">clientX</span><span class="p">:</span> <span class="mi">232</span>
                <span class="nx">clientY</span><span class="p">:</span> <span class="mi">96</span>
                <span class="nx">force</span><span class="p">:</span> <span class="mi">1</span> <span class="c1">// 触摸压力</span>
                <span class="nx">identifier</span><span class="p">:</span> <span class="mi">0</span> <span class="c1">// 唯一ID</span>
                <span class="nx">pageX</span><span class="p">:</span> <span class="mi">232</span>
                <span class="nx">pageY</span><span class="p">:</span> <span class="mi">96</span>
                <span class="nx">radiusX</span><span class="p">:</span> <span class="mf">11.5</span>
                <span class="nx">radiusY</span><span class="p">:</span> <span class="mf">11.5</span>
                <span class="nx">region</span><span class="p">:</span> <span class="kc">null</span>
                <span class="nx">rotationAngle</span><span class="p">:</span> <span class="mi">0</span>
                <span class="nx">screenX</span><span class="p">:</span> <span class="mi">476</span>
                <span class="nx">screenY</span><span class="p">:</span> <span class="mi">266</span>
                <span class="nx">target</span><span class="p">:</span> <span class="nx">html</span> <span class="c1">// 触摸目标元素</span>
                <span class="nx">__proto__</span><span class="p">:</span> <span class="nx">Touch</span>
                <span class="nx">length</span><span class="p">:</span> <span class="mi">1</span>

    	<span class="nx">__proto__</span><span class="p">:</span> <span class="nx">TouchList</span>

    <span class="nx">composed</span><span class="p">:</span> <span class="kc">true</span>
    <span class="nx">ctrlKey</span><span class="p">:</span> <span class="kc">false</span>
    <span class="nx">currentTarget</span><span class="p">:</span> <span class="kc">null</span>
    <span class="nx">defaultPrevented</span><span class="p">:</span> <span class="kc">false</span>
    <span class="nx">detail</span><span class="p">:</span> <span class="mi">0</span>
    <span class="nx">eventPhase</span><span class="p">:</span> <span class="mi">0</span>
    <span class="nx">isTrusted</span><span class="p">:</span> <span class="kc">true</span>
    <span class="nx">metaKey</span><span class="p">:</span> <span class="kc">false</span>
    <span class="nx">path</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="nx">html</span><span class="p">,</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">Window</span><span class="p">]</span>
    <span class="nx">returnValue</span><span class="p">:</span> <span class="kc">true</span>
    <span class="nx">shiftKey</span><span class="p">:</span> <span class="kc">false</span>
    <span class="nx">sourceCapabilities</span><span class="p">:</span> <span class="nx">InputDeviceCapabilities</span> <span class="p">{</span><span class="nl">firesTouchEvents</span><span class="p">:</span> <span class="kc">true</span><span class="p">}</span>
    <span class="nl">srcElement</span><span class="p">:</span> <span class="nx">html</span>
    <span class="nx">target</span><span class="p">:</span> <span class="nx">html</span>
    <span class="nx">targetTouches</span><span class="p">:</span> <span class="nx">TouchList</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="nx">Touch</span><span class="p">,</span> <span class="nx">length</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="c1">// TouchList 接口 （所有触摸点集合）</span>
    <span class="nl">timeStamp</span><span class="p">:</span> <span class="mf">994.1749999998137</span>
    <span class="nx">touches</span><span class="p">:</span> <span class="nx">TouchList</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="nx">Touch</span><span class="p">,</span> <span class="nx">length</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="c1">// TouchList 接口 （所有触摸点集合）</span>
    <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">touchmove</span><span class="dl">"</span> <span class="c1">// 当前触摸事件类型</span>
    <span class="nx">view</span><span class="p">:</span> <span class="nx">Window</span> <span class="p">{</span><span class="nl">postMessage</span><span class="p">:</span> <span class="nx">ƒ</span><span class="p">,</span> <span class="nx">blur</span><span class="p">:</span> <span class="nx">ƒ</span><span class="p">,</span> <span class="nx">focus</span><span class="p">:</span> <span class="nx">ƒ</span><span class="p">,</span> <span class="nx">close</span><span class="p">:</span> <span class="nx">ƒ</span><span class="p">,</span> <span class="nx">parent</span><span class="p">:</span> <span class="nx">Window</span><span class="p">,</span> <span class="err">…</span><span class="p">}</span>
    <span class="nl">which</span><span class="p">:</span> <span class="mi">0</span>

</code></pre></div></div>

<h3 id="2touch-接口">2、Touch 接口</h3>

<h4 id="21-touch-接口概述-单个触摸点">2.1 Touch 接口概述 （单个触摸点）</h4>

<p>Touch 接口<strong>代表单个触摸点</strong>。触摸点可能是一根手指，也可能是一根触摸笔。</p>

<p>浏览器原生提供<code class="language-plaintext highlighter-rouge">Touch</code>构造函数，用来生成<code class="language-plaintext highlighter-rouge">Touch</code>实例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">touch</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Touch</span><span class="p">(</span><span class="nx">touchOptions</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Touch</code>构造函数接受一个<strong>配置对象作为参数</strong>，它有以下属性。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li>
  <li><code class="language-plaintext highlighter-rouge">target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li>
  <li><code class="language-plaintext highlighter-rouge">clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li>
  <li><code class="language-plaintext highlighter-rouge">clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li>
  <li><code class="language-plaintext highlighter-rouge">screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li>
  <li><code class="language-plaintext highlighter-rouge">screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li>
  <li><code class="language-plaintext highlighter-rouge">pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li>
  <li><code class="language-plaintext highlighter-rouge">pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li>
  <li><code class="language-plaintext highlighter-rouge">radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li>
  <li><code class="language-plaintext highlighter-rouge">radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li>
  <li><code class="language-plaintext highlighter-rouge">rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li>
  <li><code class="language-plaintext highlighter-rouge">force</code>：可选，类型为数值，范围在<code class="language-plaintext highlighter-rouge">0</code>到<code class="language-plaintext highlighter-rouge">1</code>之间，表示触摸压力。<code class="language-plaintext highlighter-rouge">0</code>代表没有压力，<code class="language-plaintext highlighter-rouge">1</code>代表硬件所能识别的最大压力，默认为<code class="language-plaintext highlighter-rouge">0</code>。</li>
</ul>

<h4 id="22-touch-接口的实例属性">2.2 Touch 接口的实例属性</h4>

<h5 id="1touchidentifier-触摸点的id">（1）Touch.identifier 触摸点的ID</h5>

<p><code class="language-plaintext highlighter-rouge">Touch.identifier</code>属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">someElement</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">touchmove</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">changedTouches</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">changedTouches</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">identifier</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="2touchscreenxtouchscreenytouchclientxtouchclientypagexpagey-相对屏幕浏览器文档的坐标">（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY （相对屏幕、浏览器、文档的坐标）</h5>

<p><code class="language-plaintext highlighter-rouge">Touch.screenX</code>属性和<code class="language-plaintext highlighter-rouge">Touch.screenY</code>属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。</p>

<p><code class="language-plaintext highlighter-rouge">Touch.clientX</code>属性和<code class="language-plaintext highlighter-rouge">Touch.clientY</code>属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。</p>

<p><code class="language-plaintext highlighter-rouge">Touch.pageX</code>属性和<code class="language-plaintext highlighter-rouge">Touch.pageY</code>属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。</p>

<h5 id="3touchradiusxtouchradiusytouchrotationangle-触摸椭圆区域半径角度">（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle （触摸椭圆区域半径、角度）</h5>

<p><code class="language-plaintext highlighter-rouge">Touch.radiusX</code>属性和<code class="language-plaintext highlighter-rouge">Touch.radiusY</code>属性，分别返回<strong>触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度</strong>。</p>

<p><code class="language-plaintext highlighter-rouge">Touch.rotationAngle</code>属性表示触摸区域的椭圆的旋转角度，单位为度数，在<code class="language-plaintext highlighter-rouge">0</code>到<code class="language-plaintext highlighter-rouge">90</code>度之间。</p>

<p>上面这三个属性共同定义了<strong>用户与屏幕接触的区域</strong>，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。</p>

<p>下面是一个示例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">touchstart</span><span class="dl">'</span><span class="p">,</span> <span class="nx">rotate</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">touchmove</span><span class="dl">'</span><span class="p">,</span> <span class="nx">rotate</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">touchend</span><span class="dl">'</span><span class="p">,</span> <span class="nx">rotate</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">rotate</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">touch</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">changedTouches</span><span class="p">.</span><span class="nx">item</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>

  <span class="nx">src</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">touch</span><span class="p">.</span><span class="nx">radiusX</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">px</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">src</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">touch</span><span class="p">.</span><span class="nx">radiusY</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">px</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">src</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">rotate(</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">touch</span><span class="p">.</span><span class="nx">rotationAngle</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">deg)</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h5 id="4touchforce-触摸压力">（4）Touch.force 触摸压力</h5>

<p><code class="language-plaintext highlighter-rouge">Touch.force</code>属性返回一个<code class="language-plaintext highlighter-rouge">0</code>到<code class="language-plaintext highlighter-rouge">1</code>之间的数值，表示触摸压力。<code class="language-plaintext highlighter-rouge">0</code>代表没有压力，<code class="language-plaintext highlighter-rouge">1</code>代表硬件所能识别的最大压力。</p>

<h5 id="5touchtarget-开始触摸时的元素">（5）Touch.target 开始触摸时的元素</h5>

<p><code class="language-plaintext highlighter-rouge">Touch.target</code>属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</p>

<h3 id="3touchlist-接口">3、TouchList 接口</h3>

<p><code class="language-plaintext highlighter-rouge">TouchList</code>接口<strong>表示一组触摸点的集合</strong>。它的实例是一个<strong>类似数组的对象</strong>，成员是<code class="language-plaintext highlighter-rouge">Touch</code>的实例对象，表示所有触摸点。用户用三根手指触摸，产生的<code class="language-plaintext highlighter-rouge">TouchList</code>实例就会包含三个成员，每根手指的触摸点对应一个<code class="language-plaintext highlighter-rouge">Touch</code>实例对象。</p>

<p>它的实例主要通过触摸事件的<code class="language-plaintext highlighter-rouge">TouchEvent.touches</code>、<code class="language-plaintext highlighter-rouge">TouchEvent.changedTouches</code>、<code class="language-plaintext highlighter-rouge">TouchEvent.targetTouches</code>这几个属性获取。</p>

<p>它的实例属性和实例方法只有两个。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li>
  <li><code class="language-plaintext highlighter-rouge">TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li>
</ul>

<h3 id="4touchevent-接口">4、TouchEvent 接口</h3>

<h4 id="41-概述">4.1 概述</h4>

<p>TouchEvent 接口<strong>继承了 Event 接口</strong>，表示由<strong>触摸引发的事件实例</strong>，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。</p>

<p>浏览器原生提供<code class="language-plaintext highlighter-rouge">TouchEvent()</code>构造函数，用来生成触摸事件的实例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nx">TouchEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">TouchEvent()</code>构造函数可以接受两个参数，第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了<code class="language-plaintext highlighter-rouge">Event</code>接口的配置属性，该接口还有一些自己的配置属性。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">touches</code>：<code class="language-plaintext highlighter-rouge">TouchList</code>实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组<code class="language-plaintext highlighter-rouge">[]</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">targetTouches</code>：<code class="language-plaintext highlighter-rouge">TouchList</code>实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组<code class="language-plaintext highlighter-rouge">[]</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">changedTouches</code>：<code class="language-plaintext highlighter-rouge">TouchList</code>实例，代表本次触摸事件的相关触摸点，默认值是一个空数组<code class="language-plaintext highlighter-rouge">[]</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为<code class="language-plaintext highlighter-rouge">false</code>。</li>
</ul>

<h4 id="42-实例属性">4.2 实例属性</h4>

<p>TouchEvent 接口的实例具有<code class="language-plaintext highlighter-rouge">Event</code>实例的所有属性和方法，此外还有一些它自己的实例属性，这些属性全部都是只读。</p>

<h5 id="1toucheventaltkeytoucheventctrlkeytoucheventshiftkeytoucheventmetakey-是否同时按某些功能键">（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey （是否同时按某些功能键）</h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TouchEvent.altKey</code>：布尔值，表示触摸时是否按下了 Alt 键。</li>
  <li><code class="language-plaintext highlighter-rouge">TouchEvent.ctrlKey</code>：布尔值，表示触摸时是否按下了 Ctrl 键。</li>
  <li><code class="language-plaintext highlighter-rouge">TouchEvent.shiftKey</code>：布尔值：表示触摸时是否按下了 Shift 键。</li>
  <li><code class="language-plaintext highlighter-rouge">TouchEvent.metaKey</code>：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。</li>
</ul>

<p>下面是一个示例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">someElement</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">touchstart</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">altKey = </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">altKey</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ctrlKey = </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ctrlKey</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">metaKey = </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">metaKey</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">shiftKey = </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">shiftKey</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="2toucheventchangedtouches-触摸点集合不同触摸事件含义不同">（2）TouchEvent.changedTouches （触摸点集合，不同触摸事件，含义不同）</h5>

<p><code class="language-plaintext highlighter-rouge">TouchEvent.changedTouches</code>属性返回一个<code class="language-plaintext highlighter-rouge">TouchList</code>实例，成员是一组<code class="language-plaintext highlighter-rouge">Touch</code>实例对象，表示本次触摸事件的相关触摸点。</p>

<p>对于<strong>不同的事件，该属性的含义有所不同。</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">touchstart</code>事件：被激活的触摸点</li>
  <li><code class="language-plaintext highlighter-rouge">touchmove</code>事件：发生变化的触摸点</li>
  <li><code class="language-plaintext highlighter-rouge">touchend</code>事件：消失的触摸点（即不再被触碰的点）</li>
</ul>

<p>下面是一个示例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">someElement</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">touchmove</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">changedTouches</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">changedTouches</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">identifier</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="3toucheventtouches-仍然活动的触摸点集合">（3）TouchEvent.touches （仍然活动的触摸点集合）</h5>

<p><code class="language-plaintext highlighter-rouge">TouchEvent.touches</code>属性返回一个<code class="language-plaintext highlighter-rouge">TouchList</code>实例，成员是所有<strong>仍然处于活动状态（即触摸中）的触摸点</strong>。一般来说，一个手指就是一个触摸点。</p>

<p>下面是一个示例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">someElement</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">touchstart</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">touches</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 一根手指触摸</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="nx">handle_one_touch</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="c1">// 两根手指触摸</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="nx">handle_two_touches</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="c1">// 三根手指触摸</span>
    <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="nx">handle_three_touches</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="c1">// 其他情况</span>
    <span class="nl">default</span><span class="p">:</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Not supported</span><span class="dl">'</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="4toucheventtargettouches-目标元素内活动的触摸点集合">（4）TouchEvent.targetTouches （目标元素内活动的触摸点集合）</h5>

<p><code class="language-plaintext highlighter-rouge">TouchEvent.targetTouches</code>属性返回一个<code class="language-plaintext highlighter-rouge">TouchList</code>实例，成员是<strong>触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">touches_in_target</span><span class="p">(</span><span class="nx">ev</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">ev</span><span class="p">.</span><span class="nx">touches</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">targetTouches</span><span class="p">.</span><span class="nx">length</span> <span class="p">?</span> <span class="kc">true</span> <span class="p">:</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码用来判断，是否所有触摸点都在目标元素内。</p>

<h3 id="5触摸事件的种类">5、触摸事件的种类</h3>

<p>触摸引发的事件，有以下几种。可以通过<code class="language-plaintext highlighter-rouge">TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">touchstart</code>：用户开始触摸时触发，它的<code class="language-plaintext highlighter-rouge">target</code>属性返回发生触摸的元素节点。<strong>【开始触摸】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code class="language-plaintext highlighter-rouge">target</code>属性与<code class="language-plaintext highlighter-rouge">touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code class="language-plaintext highlighter-rouge">changedTouches</code>属性返回一个<code class="language-plaintext highlighter-rouge">TouchList</code>实例，包含所有不再触摸的触摸点（即<code class="language-plaintext highlighter-rouge">Touch</code>实例对象）。<strong>【触摸结束】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">touchmove</code>：用户移动触摸点时触发，它的<code class="language-plaintext highlighter-rouge">target</code>属性与<code class="language-plaintext highlighter-rouge">touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。<strong>【触摸移动中】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。<strong>【触摸点被取消】</strong></li>
</ul>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">canvas</span><span class="dl">'</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">touchstart</span><span class="dl">'</span><span class="p">,</span> <span class="nx">handleStart</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">touchmove</span><span class="dl">'</span><span class="p">,</span> <span class="nx">handleMove</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">handleStart</span><span class="p">(</span><span class="nx">evt</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">evt</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">touches</span> <span class="o">=</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">changedTouches</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">touches</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">touches</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">pageX</span><span class="p">,</span> <span class="nx">touches</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">pageY</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">handleMove</span><span class="p">(</span><span class="nx">evt</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">evt</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">touches</span> <span class="o">=</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">changedTouches</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">touches</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">touch</span> <span class="o">=</span> <span class="nx">touches</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">touch</span><span class="p">.</span><span class="nx">pageX</span><span class="p">,</span> <span class="nx">touch</span><span class="p">.</span><span class="nx">pageY</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="九拖拉事件">九、拖拉事件</h2>

<h3 id="1拖拉事件的种类">1、拖拉事件的种类</h3>

<p>拖拉（drag）指的是，<strong>用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里</strong>。</p>

<p>拖拉的对象有好几种，包括<strong>元素节点、图片、链接、选中的文字等等</strong>。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让元素节点可拖拉，可以将该节点的<code class="language-plaintext highlighter-rouge">draggable</code>属性设为<code class="language-plaintext highlighter-rouge">true</code>。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">draggable=</span><span class="s">"true"</span><span class="nt">&gt;</span>
  此区域可拖拉
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">draggable</code>属性<strong>可用于任何元素节点</strong>，但是图片（<code class="language-plaintext highlighter-rouge">  &lt;img&gt;  </code>）和链接（<code class="language-plaintext highlighter-rouge">  &lt;a&gt;  </code>）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为<code class="language-plaintext highlighter-rouge">false</code>，防止拖拉这两种元素。</p>

<p><strong>注意</strong>，一旦某个元素节点的<code class="language-plaintext highlighter-rouge">draggable</code>属性设为<code class="language-plaintext highlighter-rouge">true</code>，<strong>就无法再用鼠标选中该节点内部的文字或子节点</strong>了。</p>

<p>当元素节点或选中的文本被拖拉时，就<strong>会持续触发拖拉事件</strong>，包括以下一些事件。</p>

<p><strong>拖拉的节点上触发：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">drag</code>：<strong>拖拉过程中</strong>，在被拖拉的节点上<strong>持续触发</strong>（相隔几百毫秒）。</li>
  <li><code class="language-plaintext highlighter-rouge">dragstart</code>：用户<strong>开始拖拉时</strong>，在被拖拉的节点上触发，该事件的<code class="language-plaintext highlighter-rouge">target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li>
  <li><code class="language-plaintext highlighter-rouge">dragend</code>：<strong>拖拉结束时</strong>（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code class="language-plaintext highlighter-rouge">target</code>属性是被拖拉的节点。它与<code class="language-plaintext highlighter-rouge">dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code class="language-plaintext highlighter-rouge">dragend</code>事件总是会触发的。</li>
</ul>

<p><strong>拖拉到别的节点上触发：</strong></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">dragenter</code>：<strong>拖拉进入当前节点</strong>时，<strong>在当前节点上触发一次</strong>，该事件的<code class="language-plaintext highlighter-rouge">target</code>属性是当前节点。通常应该在这个事件的监听函数中，<strong>指定是否允许在当前节点放下（drop）拖拉的数据</strong>。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">dragover</code>：<strong>拖拉到当前节点上方时</strong>，在当前节点上<strong>持续触发</strong>（相隔几百毫秒），该事件的<code class="language-plaintext highlighter-rouge">target</code>属性是当前节点。该事件与<code class="language-plaintext highlighter-rouge">dragenter</code>事件的区别是，<code class="language-plaintext highlighter-rouge">dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code class="language-plaintext highlighter-rouge">dragover</code>事件会持续触发。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">dragleave</code>：<strong>拖拉操作离开当前节点范围时</strong>，在当前节点上触发，该事件的<code class="language-plaintext highlighter-rouge">target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">drop</code>：被拖拉的节点或选中的文本，<strong>释放到目标节点时，在目标节点上触发</strong>。注意，如果当前节点不允许<code class="language-plaintext highlighter-rouge">drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</p>
  </li>
</ul>

<p>下面的例子展示，如何动态改变被拖动节点的背景色。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragstart</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragend</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">green</span><span class="dl">'</span><span class="p">;</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">div</code>节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"div1"</span> <span class="na">draggable=</span><span class="s">"true"</span><span class="nt">&gt;</span>
    div1，此区域可拖拉
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"div2"</span><span class="nt">&gt;</span>
    div2
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;script&gt;</span>
    <span class="kd">var</span> <span class="nx">div1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.div1</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">div2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.div2</span><span class="dl">'</span><span class="p">);</span>

    <span class="nx">div1</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragstart</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">开始拖拉</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">});</span>
    <span class="nx">div1</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">drag</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">拖拉中</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 持续触发</span>
    <span class="p">});</span>
    <span class="nx">div1</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragend</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">结束拖拉</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">});</span>


    <span class="nx">div2</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragenter</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">拖到了div2</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="nx">div2</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragover</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">//console.log('正在div2上方') // 持续触发</span>
    <span class="p">})</span>
    <span class="nx">div2</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragleave</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">离开div2</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="nx">div2</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">drop</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">在div2上释放</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">})</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>下面是一个例子，展示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* HTML 代码如下
 &lt;div class="dropzone"&gt;
   &lt;div id="draggable" draggable="true"&gt;
     该节点可拖拉
   &lt;/div&gt;
 &lt;/div&gt;
 &lt;div class="dropzone"&gt;&lt;/div&gt;
 &lt;div class="dropzone"&gt;&lt;/div&gt;
 &lt;div class="dropzone"&gt;&lt;/div&gt;
*/</span>

<span class="c1">// 被拖拉节点</span>
<span class="kd">var</span> <span class="nx">dragged</span><span class="p">;</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragstart</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 保存被拖拉节点</span>
  <span class="nx">dragged</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span>
  <span class="c1">// 被拖拉节点的背景色变透明</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">opacity</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragend</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 被拖拉节点的背景色恢复正常</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">opacity</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragover</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 防止拖拉效果被重置，允许被拖拉的节点放入目标节点</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragenter</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 目标节点的背景色变紫色</span>
  <span class="c1">// 由于该事件会冒泡，所以要过滤节点</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">className</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">dropzone</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">purple</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragleave</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 目标节点的背景色恢复原样</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">className</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">dropzone</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">drop</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 防止事件默认行为（比如某些元素节点上可以打开链接），</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">className</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">dropzone</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 恢复目标节点背景色</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>
    <span class="c1">// 将被拖拉节点插入目标节点</span>
    <span class="nx">dragged</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">dragged</span><span class="p">);</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span> <span class="nx">dragged</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>关于拖拉事件，有以下几个注意点。</p>

<ul>
  <li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是<strong>鼠标事件不会触发</strong>。</li>
  <li>将文件从操作系统拖拉进浏览器，不会触发<code class="language-plaintext highlighter-rouge">dragstart</code>和<code class="language-plaintext highlighter-rouge">dragend</code>事件。</li>
  <li><code class="language-plaintext highlighter-rouge">dragenter</code>和<code class="language-plaintext highlighter-rouge">dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。<strong>如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为</strong>。</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">ondragover=</span><span class="s">"return false"</span><span class="nt">&gt;</span>
<span class="nt">&lt;div</span> <span class="na">ondragover=</span><span class="s">"event.preventDefault()"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在<code class="language-plaintext highlighter-rouge">div</code>节点上放下被拖拉的节点。</p>

<h3 id="2dragevent-接口">2、DragEvent 接口</h3>

<p><strong>拖拉事件都继承了<code class="language-plaintext highlighter-rouge">DragEvent</code>接口，这个接口又继承了<code class="language-plaintext highlighter-rouge">MouseEvent</code>接口和<code class="language-plaintext highlighter-rouge">Event</code>接口。</strong></p>

<p>浏览器原生提供一个<code class="language-plaintext highlighter-rouge">DragEvent()</code>构造函数，用来生成拖拉事件的实例对象。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nx">DragEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DragEvent()</code>构造函数接受两个参数，第一个参数是<strong>字符串，表示事件的类型</strong>，该参数必须；第二个参数是事件的<strong>配置对象</strong>，用来设置事件的属性，该参数可选。配置对象除了接受<code class="language-plaintext highlighter-rouge">MouseEvent</code>接口和<code class="language-plaintext highlighter-rouge">Event</code>接口的配置属性，还可以<strong>设置<code class="language-plaintext highlighter-rouge">dataTransfer</code>属性要么是<code class="language-plaintext highlighter-rouge">null</code>，要么是一个<code class="language-plaintext highlighter-rouge">DataTransfer</code>接口的实例。</strong></p>

<p><code class="language-plaintext highlighter-rouge">DataTransfer</code>的实例对象用来读写拖拉事件中传输的数据，详见下文《DataTransfer 接口》的部分。</p>

<h3 id="3datatransfer-接口概述">3、DataTransfer 接口概述</h3>

<p><strong>所有拖拉事件的实例都有一个<code class="language-plaintext highlighter-rouge">DragEvent.dataTransfer</code>属性，用来读写需要传递的数据</strong>。这个属性的值是一个<code class="language-plaintext highlighter-rouge">DataTransfer</code>接口的实例。</p>

<p>浏览器原生提供一个<code class="language-plaintext highlighter-rouge">DataTransfer()</code>构造函数，用来生成<code class="language-plaintext highlighter-rouge">DataTransfer</code>实例对象。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">dataTrans</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataTransfer</span><span class="p">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DataTransfer()</code>构造函数<strong>不接受参数</strong>。</p>

<p>拖拉的数据分成两方面：<strong>数据的种类（又称格式）和数据的值</strong>。数据的种类是一个 MIME 字符串（比如<code class="language-plaintext highlighter-rouge">text/plain</code>、<code class="language-plaintext highlighter-rouge">image/jpeg</code>），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。</p>

<p>拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过<code class="language-plaintext highlighter-rouge">dragenter</code>和<code class="language-plaintext highlighter-rouge">dragover</code>事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为<code class="language-plaintext highlighter-rouge">text/uri-list</code>。</p>

<p><strong>发生<code class="language-plaintext highlighter-rouge">drop</code>事件时，监听函数取出拖拉的数据，对其进行处理。</strong></p>

<h3 id="4datatransfer-的实例属性">4、DataTransfer 的实例属性</h3>

<h4 id="41-datatransferdropeffect-设置接受拖拉的区域的效果">4.1 DataTransfer.dropEffect 设置接受拖拉的区域的效果</h4>

<p><code class="language-plaintext highlighter-rouge">DataTransfer.dropEffect</code>属性<strong>用来设置放下（drop）被拖拉节点时的效果</strong>，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。</p>

<ul>
  <li>copy：复制被拖拉的节点</li>
  <li>move：移动被拖拉的节点</li>
  <li>link：创建指向被拖拉的节点的链接</li>
  <li>none：无法放下被拖拉的节点</li>
</ul>

<p>除了上面这些值，设置其他的值都是无效的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">target</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragover</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">dropEffect</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码中，被拖拉元素一旦<code class="language-plaintext highlighter-rouge">drop</code>，接受的区域会复制该节点。</p>

<p><code class="language-plaintext highlighter-rouge">dropEffect</code>属性一般<strong>在<code class="language-plaintext highlighter-rouge">dragenter</code>和<code class="language-plaintext highlighter-rouge">dragover</code>事件的监听函数中设置</strong>，对于<code class="language-plaintext highlighter-rouge">dragstart</code>、<code class="language-plaintext highlighter-rouge">drag</code>、<code class="language-plaintext highlighter-rouge">dragleave</code>这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果。</p>

<h4 id="42-datatransfereffectallowed-设置被拖拉的节点允许的效果">4.2 DataTransfer.effectAllowed 设置被拖拉的节点允许的效果</h4>

<p><code class="language-plaintext highlighter-rouge">DataTransfer.effectAllowed</code>属性<strong>设置本次拖拉中允许的效果</strong>。它可能取下面的值。</p>

<ul>
  <li>copy：复制被拖拉的节点</li>
  <li>move：移动被拖拉的节点</li>
  <li>link：创建指向被拖拉节点的链接</li>
  <li>copyLink：允许<code class="language-plaintext highlighter-rouge">copy</code>或<code class="language-plaintext highlighter-rouge">link</code></li>
  <li>copyMove：允许<code class="language-plaintext highlighter-rouge">copy</code>或<code class="language-plaintext highlighter-rouge">move</code></li>
  <li>linkMove：允许<code class="language-plaintext highlighter-rouge">link</code>或<code class="language-plaintext highlighter-rouge">move</code></li>
  <li>all：允许所有效果</li>
  <li>none：无法放下被拖拉的节点</li>
  <li>uninitialized：默认值，等同于<code class="language-plaintext highlighter-rouge">all</code></li>
</ul>

<p>如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。</p>

<p><strong>这个属性与<code class="language-plaintext highlighter-rouge">dropEffect</code>属性是同一件事的两个方面。前者设置被拖拉的节点允许的效果，后者设置接受拖拉的区域的效果，它们往往配合使用。</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">dragstart</code>事件的监听函数，可以用来设置这个属性</strong>。其他事件的监听函数里面设置这个属性是无效的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">source</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragstart</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 被拖拉节点上设置</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">effectAllowed</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">move</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">target</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragover</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 接受区域节点上设置</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">dropEffect</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">move</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>只要<code class="language-plaintext highlighter-rouge">dropEffect</code>属性和<code class="language-plaintext highlighter-rouge">effectAllowed</code>属性之中，有一个为<code class="language-plaintext highlighter-rouge">none</code>，就无法在目标节点上完成<code class="language-plaintext highlighter-rouge">drop</code>操作。</p>

<h4 id="43-datatransferfiles-本地文件">4.3 DataTransfer.files 本地文件</h4>

<p><code class="language-plaintext highlighter-rouge">DataTransfer.files</code>属性是<strong>一个 FileList 对象，包含一组本地文件</strong>，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。</p>

<h5 id="例子接收拖拉文件">例子：接收拖拉文件</h5>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;div id="output" style="min-height: 200px;border: 1px solid black;"&gt;</span>
<span class="c1">//   文件拖拉到这里</span>
<span class="c1">// &lt;/div&gt;</span>

<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">output</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">dragenter</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">)</span> <span class="p">{</span>
  <span class="nx">div</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">dragover</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">drop</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">event</span> <span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">files</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">files</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">files</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">div</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">+=</span> <span class="nx">files</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">name</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">files</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">size</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">字节</span><span class="se">\n</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，通过<code class="language-plaintext highlighter-rouge">dataTransfer.files</code>属性读取被拖拉的文件的信息。如果想要<strong>读取文件内容，就要使用<code class="language-plaintext highlighter-rouge">FileReader</code>对象。</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">drop</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>

  <span class="kd">var</span> <span class="nx">fileList</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">files</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">fileList</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">fileList</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">();</span>
    <span class="nx">reader</span><span class="p">.</span><span class="nx">readAsDataURL</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span><span class="c1">// 解析为url</span>
    <span class="nx">reader</span><span class="p">.</span><span class="nx">onloadend</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="nx">FileReader</span><span class="p">.</span><span class="nx">DONE</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">content</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
        <span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">&lt;img src="</span><span class="dl">'</span><span class="o">+</span> <span class="nx">content</span> <span class="o">+</span><span class="dl">'</span><span class="s1">"&gt; File: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">file</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="dl">'</span><span class="se">\n\n</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">content</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">reader</span><span class="p">.</span><span class="nx">readAsBinaryString</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<h4 id="44-datatransfertypes-数据格式">4.4 DataTransfer.types 数据格式</h4>

<p><code class="language-plaintext highlighter-rouge">DataTransfer.types</code>属性<strong>是一个只读的数组</strong>，每个成员是一个字符串，里面是<strong>拖拉的数据格式</strong>（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是<code class="language-plaintext highlighter-rouge">text/plain</code>。</p>

<p>下面是一个例子，通过检查<code class="language-plaintext highlighter-rouge">dataTransfer</code>属性的类型，决定是否允许在当前节点执行<code class="language-plaintext highlighter-rouge">drop</code>操作。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">contains</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">value</span><span class="p">){</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">value</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">doDragOver</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">isLink</span> <span class="o">=</span> <span class="nx">contains</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">types</span><span class="p">,</span> <span class="dl">'</span><span class="s1">text/uri-list</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isLink</span><span class="p">)</span> <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，只有当被拖拉的节点是一个链接时，才允许在当前节点放下。</p>

<h4 id="45-datatransferitems">4.5 DataTransfer.items</h4>

<p><code class="language-plaintext highlighter-rouge">DataTransfer.items</code>属性<strong>返回一个类似数组的只读对象（DataTransferItemList 实例）</strong>，每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。</p>

<p>DataTransferItemList 实例具有以下的属性和方法。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">length</code>：返回成员的数量</li>
  <li><code class="language-plaintext highlighter-rouge">add(data, type)</code>：增加一个指定内容和类型（比如<code class="language-plaintext highlighter-rouge">text/html</code>和<code class="language-plaintext highlighter-rouge">text/plain</code>）的字符串作为成员</li>
  <li><code class="language-plaintext highlighter-rouge">add(file)</code>：<code class="language-plaintext highlighter-rouge">add</code>方法的另一种用法，增加一个文件作为成员</li>
  <li><code class="language-plaintext highlighter-rouge">remove(index)</code>：移除指定位置的成员</li>
  <li><code class="language-plaintext highlighter-rouge">clear()</code>：移除所有的成员</li>
</ul>

<p>DataTransferItem 实例具有以下的属性和方法。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">kind</code>：返回成员的种类（<code class="language-plaintext highlighter-rouge">string</code>还是<code class="language-plaintext highlighter-rouge">file</code>）。</li>
  <li><code class="language-plaintext highlighter-rouge">type</code>：返回成员的类型（通常是 MIME 值）。</li>
  <li><code class="language-plaintext highlighter-rouge">getAsFile()</code>：如果被拖拉是文件，返回该文件，否则返回<code class="language-plaintext highlighter-rouge">null</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">getAsString(callback)</code>：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。</li>
</ul>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">drop</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">items</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">kind</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">type</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="5datatransfer-的实例方法">5、DataTransfer 的实例方法</h3>

<h4 id="51-datatransfersetdata-设置拖拉事件所带有的数据">5.1 DataTransfer.setData() 设置拖拉事件所带有的数据</h4>

<p><code class="language-plaintext highlighter-rouge">DataTransfer.setData()</code>方法用来<strong>设置拖拉事件所带有的数据</strong>。该方法没有返回值。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Text to drag</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码为当前的拖拉事件加入纯文本数据。</p>

<p>该方法接受两个参数，都是字符串。第一个参数<strong>表示数据类型</strong>（比如<code class="language-plaintext highlighter-rouge">text/plain</code>），第二个参数是<strong>具体数据</strong>。如果指定类型的数据在<code class="language-plaintext highlighter-rouge">dataTransfer</code>属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。</p>

<p>如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到<code class="language-plaintext highlighter-rouge">dataTransfer</code>属性，不用手动指定。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">draggable=</span><span class="s">"true"</span><span class="nt">&gt;</span>
  aaa
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>上面代码中，拖拉这个<code class="language-plaintext highlighter-rouge">  &lt;div&gt;  </code>元素会自动带上文本数据<code class="language-plaintext highlighter-rouge">aaa</code>。</p>

<p>使用<code class="language-plaintext highlighter-rouge">setData</code>方法，可以替换到原有数据。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span>
  <span class="na">draggable=</span><span class="s">"true"</span>
  <span class="na">ondragstart=</span><span class="s">"event.dataTransfer.setData('text/plain', 'bbb')"</span>
<span class="nt">&gt;</span>
  aaa
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>上面代码中，拖拉数据实际上是<code class="language-plaintext highlighter-rouge">bbb</code>，而不是<code class="language-plaintext highlighter-rouge">aaa</code>。</p>

<p>下面是添加其他类型的数据。由于<code class="language-plaintext highlighter-rouge">text/plain</code>是最普遍支持的格式，为了保证兼容性，建议最后总是保存一份纯文本格式的数据。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">dt</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">;</span>

<span class="c1">// 添加链接</span>
<span class="nx">dt</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/uri-list</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://www.example.com</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">dt</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://www.example.com</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 添加 HTML 代码</span>
<span class="nx">dt</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/html</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello there, &lt;strong&gt;stranger&lt;/strong&gt;</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">dt</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello there, &lt;strong&gt;stranger&lt;/strong&gt;</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 添加图像的 URL</span>
<span class="nx">dt</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/uri-list</span><span class="dl">'</span><span class="p">,</span> <span class="nx">imageurl</span><span class="p">);</span>
<span class="nx">dt</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">,</span> <span class="nx">imageurl</span><span class="p">);</span>
</code></pre></div></div>

<p>可以一次提供多种格式的数据。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">dt</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">;</span>
<span class="nx">dt</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">application/x-bookmark</span><span class="dl">'</span><span class="p">,</span> <span class="nx">bookmarkString</span><span class="p">);</span>
<span class="nx">dt</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/uri-list</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://www.example.com</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">dt</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://www.example.com</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，通过在同一个事件上面，存放三种类型的数据，使得拖拉事件可以在不同的对象上面，<code class="language-plaintext highlighter-rouge">drop</code>不同的值。注意，第一种格式是一个自定义格式，浏览器默认无法读取，这意味着，只有某个部署了特定代码的节点，才可能<code class="language-plaintext highlighter-rouge">drop</code>（读取到）这个数据。</p>

<h4 id="52-datatransfergetdata-返回指定类型的数据">5.2 DataTransfer.getData() 返回指定类型的数据</h4>

<p><code class="language-plaintext highlighter-rouge">DataTransfer.getData()</code>方法接受一个字符串（表示数据类型）作为参数，<strong>返回事件所带的指定类型的数据（通常是用<code class="language-plaintext highlighter-rouge">setData</code>方法添加的数据）</strong>。如果指定类型的数据不存在，则返回空字符串。通常只有<code class="language-plaintext highlighter-rouge">drop</code>事件触发后，才能取出数据。</p>

<p>下面是一个<code class="language-plaintext highlighter-rouge">drop</code>事件的监听函数，用来取出指定类型的数据。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">onDrop</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">getData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。</p>

<p><code class="language-plaintext highlighter-rouge">getData</code>方法返回的是一个字符串，如果其中包含多项数据，就必须手动解析。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">doDrop</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">lines</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">getData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/uri-list</span><span class="dl">'</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">lines</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">link</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">link</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">line</span><span class="p">;</span>
    <span class="nx">link</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">line</span><span class="p">;</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">link</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">getData</code>方法返回的是一组链接，就必须自行解析。</p>

<p>类型值指定为<code class="language-plaintext highlighter-rouge">URL</code>，可以取出第一个有效链接。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">link</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">getData</span><span class="p">(</span><span class="dl">'</span><span class="s1">URL</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>下面的例子是从多种类型的数据里面取出数据。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">doDrop</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">types</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">types</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">supportedTypes</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">text/uri-list</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">];</span>
  <span class="nx">types</span> <span class="o">=</span> <span class="nx">supportedTypes</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="nx">types</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">});</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">getData</span><span class="p">(</span><span class="nx">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="53-datatransfercleardata-清除指定或全部数据">5.3 DataTransfer.clearData() 清除指定或全部数据</h4>

<p><code class="language-plaintext highlighter-rouge">DataTransfer.clearData()</code>方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">clearData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/uri-list</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码清除事件所带的<code class="language-plaintext highlighter-rouge">text/uri-list</code>类型的数据。</p>

<p>该方法不会移除拖拉的文件，因此调用该方法后，<code class="language-plaintext highlighter-rouge">DataTransfer.types</code>属性可能依然会返回<code class="language-plaintext highlighter-rouge">Files</code>类型（前提是存在文件拖拉）。</p>

<p>注意，该方法<strong>只能在<code class="language-plaintext highlighter-rouge">dragstart</code>事件的监听函数之中使用</strong>，因为这是拖拉操作的数据唯一可写的时机。</p>

<h4 id="54-datatransfersetdragimage-设置拖动过程中的图片">5.4 DataTransfer.setDragImage() 设置拖动过程中的图片</h4>

<p>拖动过程中（<code class="language-plaintext highlighter-rouge">dragstart</code>事件触发后），浏览器<strong>会显示一张图片跟随鼠标一起移动</strong>，表示被拖动的节点。这张图片是<strong>自动创造的</strong>，通常显示为被拖动节点的外观，不需要自己动手设置。</p>

<p><code class="language-plaintext highlighter-rouge">DataTransfer.setDragImage()</code>方法<strong>可以自定义这张图片</strong>。它接受三个参数。第一个是<code class="language-plaintext highlighter-rouge">  &lt;img&gt;  </code>节点或者<code class="language-plaintext highlighter-rouge"> &lt;canvas&gt; </code>节点，如果省略或为<code class="language-plaintext highlighter-rouge">null</code>，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。</p>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* HTML 代码如下
 &lt;div id="drag-with-image" class="dragdemo" draggable="true"&gt;
   drag me
 &lt;/div&gt;
*/</span>

<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">drag-with-image</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">dragstart</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">img</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">img</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://path/to/img</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">setDragImage</span><span class="p">(</span><span class="nx">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="十其他常见事件">十、其他常见事件</h2>

<h3 id="1资源事件">1、资源事件</h3>

<h4 id="11-beforeunload-事件-关闭窗口前调用">1.1 beforeunload 事件 （关闭窗口前调用）</h4>

<p><code class="language-plaintext highlighter-rouge">beforeunload</code>事件在<strong>窗口、文档、各种资源将要卸载前触发</strong>。它可以用来防止用户不小心卸载资源。</p>

<p>如果该事件对象的<code class="language-plaintext highlighter-rouge">returnValue</code>属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">beforeunload</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">returnValue</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">你确定离开吗？</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码中，用户如果<strong>关闭窗口，浏览器会弹出一个窗口，要求用户确认</strong>。</p>

<p>浏览器对这个事件的行为很不一致，有的浏览器调用<code class="language-plaintext highlighter-rouge">event.preventDefault()</code>，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，<strong>大多数浏览器在对话框中不显示指定文本，只显示默认文本</strong>。因此，可以采用下面的写法，取得最大的兼容性。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">beforeunload</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">confirmationMessage</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">确认关闭窗口？</span><span class="dl">'</span><span class="p">;</span>

  <span class="nx">e</span><span class="p">.</span><span class="nx">returnValue</span> <span class="o">=</span> <span class="nx">confirmationMessage</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">confirmationMessage</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>注意，许多手机浏览器默认忽略这个事件，桌面浏览器也有办法忽略这个事件。所以，它可能根本不会生效，不能依赖它来阻止用户关闭窗口。另外，一旦使用了<code class="language-plaintext highlighter-rouge">beforeunload</code>事件，浏览器就不会缓存当前网页，使用“回退”按钮将重新向服务器请求网页。这是因为监听这个事件的目的，一般是修改初始状态，这时缓存初始页面就没意义了。</p>

<p>基本上，只有一种场合可以监听<code class="language-plaintext highlighter-rouge">unload</code>事件，其他情况都不应该监听：<strong>用户修改了表单，还没有保存就要离开</strong>。</p>

<h4 id="12-unload-事件-即将关闭窗口时调用">1.2 unload 事件 （即将关闭窗口时调用）</h4>

<p><code class="language-plaintext highlighter-rouge">unload</code>事件在<strong>窗口关闭或者<code class="language-plaintext highlighter-rouge">document</code>对象将要卸载时触发</strong>。它的触发顺序排在<code class="language-plaintext highlighter-rouge">beforeunload</code>、<code class="language-plaintext highlighter-rouge">pagehide</code>事件后面。</p>

<p><code class="language-plaintext highlighter-rouge">unload</code>事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">unload</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">文档将要卸载</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>手机上，浏览器或系统可能会直接丢弃网页，这时该事件根本不会发生。而且跟<code class="language-plaintext highlighter-rouge">beforeunload</code>事件一样，一旦使用了<code class="language-plaintext highlighter-rouge">unload</code>事件，浏览器就不会缓存当前网页，理由同上。因此，任何情况下都不应该依赖这个事件，指定网页卸载时要执行的代码，可以考虑完全不使用这个事件。</p>

<h4 id="13-load-事件error-事件-abort事件-页面或某个资源加载成功失败取消时调用">1.3 load 事件，error 事件 ，abort事件 （页面或某个资源加载成功/失败/取消时调用）</h4>

<p><code class="language-plaintext highlighter-rouge">load</code>事件<strong>在页面或某个资源加载成功时触发</strong>。注意，<strong>页面或资源从浏览器缓存加载，并不会触发<code class="language-plaintext highlighter-rouge">load</code>事件</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">所有资源都加载完成</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">error</code>事件是<strong>在页面或资源加载失败时触发</strong>。</p>

<p><code class="language-plaintext highlighter-rouge">abort</code>事件是<strong>在用户取消加载时触发</strong>。</p>

<p>这三个事件实际上属于进度事件，不仅发生在<code class="language-plaintext highlighter-rouge">document</code>对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像（image）、样式表（style sheet）、脚本（script）、视频（video）、音频（audio）、Ajax请求（XMLHttpRequest）等等。这些资源和<code class="language-plaintext highlighter-rouge">document</code>对象、<code class="language-plaintext highlighter-rouge">window</code>对象、XMLHttpRequestUpload 对象，都会触发<code class="language-plaintext highlighter-rouge">load</code>事件和<code class="language-plaintext highlighter-rouge">error</code>事件。</p>

<p><strong>触发这三个事件的对象有</strong>：</p>

<ul>
  <li>window</li>
  <li>document</li>
  <li>body</li>
  <li>img</li>
  <li>style</li>
  <li>script</li>
  <li>video</li>
  <li>audio</li>
  <li>Ajax</li>
  <li>等等</li>
</ul>

<h3 id="2session-历史事件">2、session 历史事件</h3>

<h4 id="21-pageshow-事件页面显示加载页面后执行pagehide-事件退出当前页面触发">2.1 pageshow 事件（页面显示，加载页面后执行），pagehide 事件（退出当前页面触发）</h4>

<p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户<strong>点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。</strong></p>

<p>pageshow 事件<strong>在页面加载时触发，包括第一次加载和从缓存加载两种情况</strong>。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</p>

<p>第一次加载时，它的触发顺序排在<code class="language-plaintext highlighter-rouge">load</code>事件后面。从缓存加载时，<code class="language-plaintext highlighter-rouge">load</code>事件不会触发，因为网页在缓存中的样子通常是<code class="language-plaintext highlighter-rouge">load</code>事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">pageshow</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">pageshow: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">event</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>pageshow 事件<strong>有一个<code class="language-plaintext highlighter-rouge">persisted</code>属性</strong>，返回一个布尔值。页面第一次加载时，这个属性是<code class="language-plaintext highlighter-rouge">false</code>；当页面从缓存加载时，这个属性是<code class="language-plaintext highlighter-rouge">true</code>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">pageshow</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">persisted</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 是否从缓存加载</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">pagehide</code>事件与<code class="language-plaintext highlighter-rouge">pageshow</code>事件类似，当用户<strong>通过“前进/后退”按钮，离开当前页面时触发</strong>。它与 unload 事件的区别在于，如果在 window 对象上定义<code class="language-plaintext highlighter-rouge">unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code class="language-plaintext highlighter-rouge">pagehide</code>事件，页面会保存在缓存中。</p>

<p><code class="language-plaintext highlighter-rouge">pagehide</code>事件实例也<strong>有一个<code class="language-plaintext highlighter-rouge">persisted</code>属性，将这个属性设为<code class="language-plaintext highlighter-rouge">true</code>，就表示页面要保存在缓存中；设为<code class="language-plaintext highlighter-rouge">false</code>，表示网页不保存在缓存中</strong>，这时如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。</p>

<p>如果页面包含<code class="language-plaintext highlighter-rouge"> &lt;frame&gt; </code>或<code class="language-plaintext highlighter-rouge">  &lt;iframe&gt;  </code>元素，则<code class="language-plaintext highlighter-rouge"> &lt;frame&gt; </code>页面的<code class="language-plaintext highlighter-rouge">pageshow</code>事件和<code class="language-plaintext highlighter-rouge">pagehide</code>事件，都会在主页面之前触发。</p>

<p><strong>注意，这两个事件只在浏览器的<code class="language-plaintext highlighter-rouge">history</code>（历史）对象发生变化时触发，跟网页是否可见没有关系。</strong></p>

<h4 id="22-popstate-事件在浏览器的history对象的当前记录发生显式切换时触发">2.2 popstate 事件（在浏览器的<code class="language-plaintext highlighter-rouge">history</code>对象的当前记录发生显式切换时触发）</h4>

<p><code class="language-plaintext highlighter-rouge">popstate</code>事件<strong>在浏览器的<code class="language-plaintext highlighter-rouge">history</code>对象的当前记录发生显式切换时触发</strong>。注意，调用<code class="language-plaintext highlighter-rouge">history.pushState()</code>或<code class="language-plaintext highlighter-rouge">history.replaceState()</code>，并不会触发<code class="language-plaintext highlighter-rouge">popstate</code>事件。该事件只在用户在<code class="language-plaintext highlighter-rouge">history</code>记录之间显式切换时触发，比如<strong>鼠标点击“后退/前进”按钮，或者在脚本中调用<code class="language-plaintext highlighter-rouge">history.back()</code>、<code class="language-plaintext highlighter-rouge">history.forward()</code>、<code class="language-plaintext highlighter-rouge">history.go()</code>时触发</strong>。</p>

<p>该事件对象有一个<code class="language-plaintext highlighter-rouge">state</code>属性，保存<code class="language-plaintext highlighter-rouge">history.pushState</code>方法和<code class="language-plaintext highlighter-rouge">history.replaceState</code>方法为当前记录添加的<code class="language-plaintext highlighter-rouge">state</code>对象。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onpopstate</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">state: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">state</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">history</span><span class="p">.</span><span class="nx">pushState</span><span class="p">({</span><span class="na">page</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="dl">'</span><span class="s1">title 1</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">?page=1</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">history</span><span class="p">.</span><span class="nx">pushState</span><span class="p">({</span><span class="na">page</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="dl">'</span><span class="s1">title 2</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">?page=2</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">history</span><span class="p">.</span><span class="nx">replaceState</span><span class="p">({</span><span class="na">page</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="dl">'</span><span class="s1">title 3</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">?page=3</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">history</span><span class="p">.</span><span class="nx">back</span><span class="p">();</span> <span class="c1">// state: {"page":1}</span>
<span class="nx">history</span><span class="p">.</span><span class="nx">back</span><span class="p">();</span> <span class="c1">// state: null</span>
<span class="nx">history</span><span class="p">.</span><span class="nx">go</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">// state: {"page":3}</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">pushState</code>方法向<code class="language-plaintext highlighter-rouge">history</code>添加了两条记录，然后<code class="language-plaintext highlighter-rouge">replaceState</code>方法替换掉当前记录。因此，连续两次<code class="language-plaintext highlighter-rouge">back</code>方法，会让当前条目退回到原始网址，它没有附带<code class="language-plaintext highlighter-rouge">state</code>对象，所以事件的<code class="language-plaintext highlighter-rouge">state</code>属性为<code class="language-plaintext highlighter-rouge">null</code>，然后前进两条记录，又回到<code class="language-plaintext highlighter-rouge">replaceState</code>方法添加的记录。</p>

<p>浏览器对于页面首次加载，是否触发<code class="language-plaintext highlighter-rouge">popstate</code>事件，处理不一样，Firefox 不触发该事件。</p>

<h4 id="23-hashchange-事件-hash发生变化时触发">2.3 hashchange 事件 （hash发生变化时触发）</h4>

<p><code class="language-plaintext highlighter-rouge">hashchange</code>事件在 U<strong>RL 的 hash 部分（即<code class="language-plaintext highlighter-rouge">#</code>号后面的部分，包括<code class="language-plaintext highlighter-rouge">#</code>号）发生变化时触发</strong>。该事件<strong>一般在<code class="language-plaintext highlighter-rouge">window</code>对象上监听</strong>。</p>

<p><code class="language-plaintext highlighter-rouge">hashchange</code>的事件实例具有两个特有属性：<code class="language-plaintext highlighter-rouge">oldURL</code>属性和<code class="language-plaintext highlighter-rouge">newURL</code>属性，分别表示变化前后的完整 URL。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// URL 是 http://www.example.com/</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">hashchange</span><span class="dl">'</span><span class="p">,</span> <span class="nx">myFunction</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">myFunction</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">oldURL</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">newURL</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">location</span><span class="p">.</span><span class="nx">hash</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">part2</span><span class="dl">'</span><span class="p">;</span>
<span class="c1">// http://www.example.com/</span>
<span class="c1">// http://www.example.com/#part2</span>
</code></pre></div></div>

<h3 id="3网页状态事件">3、网页状态事件</h3>

<h4 id="31-domcontentloaded-事件-dom内容加载完成后触发">3.1 DOMContentLoaded 事件 （DOM内容加载完成后触发）</h4>

<p><strong>网页下载并解析完成以后，浏览器就会在<code class="language-plaintext highlighter-rouge">document</code>对象上触发 DOMContentLoaded 事件</strong>。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），<strong>所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束</strong>。也就是说，这个事件<strong>比<code class="language-plaintext highlighter-rouge">load</code>事件，发生时间早得多</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">DOMContentLoaded</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">DOM生成</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发<code class="language-plaintext highlighter-rouge">DOMContentLoaded</code>事件。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">DOMContentLoaded</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">DOM 生成</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 这段代码会推迟触发 DOMContentLoaded 事件</span>
<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">1000000000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="32-readystatechange-事件document-对象和-xmlhttprequest-对象的readystate属性发生变化时触发">3.2 readystatechange 事件（Document 对象和 XMLHttpRequest 对象的<code class="language-plaintext highlighter-rouge">readyState</code>属性发生变化时触发）</h4>

<p><code class="language-plaintext highlighter-rouge">readystatechange</code>事件<strong>当 Document 对象和 XMLHttpRequest 对象的<code class="language-plaintext highlighter-rouge">readyState</code>属性发生变化时触发</strong>。<code class="language-plaintext highlighter-rouge">document.readyState</code>有三个可能的值：<code class="language-plaintext highlighter-rouge">loading</code>（网页正在加载）、<code class="language-plaintext highlighter-rouge">interactive</code>（网页已经解析完成，但是外部资源仍然处在加载状态）和<code class="language-plaintext highlighter-rouge">complete</code>（网页和所有外部资源已经结束加载，<code class="language-plaintext highlighter-rouge">load</code>事件即将触发）。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">interactive</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个事件可以看作<code class="language-plaintext highlighter-rouge">DOMContentLoaded</code>事件的另一种实现方法。</p>

<h3 id="4窗口事件">4、窗口事件</h3>

<h4 id="41-scroll-事件-文档或文档元素滚动时触发">4.1 scroll 事件 （文档或文档元素滚动时触发）</h4>

<p><code class="language-plaintext highlighter-rouge">scroll</code>事件在<strong>文档或文档元素滚动时触发</strong>，主要出现在用户拖动滚动条。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
</code></pre></div></div>

<p>该事件<strong>会连续地大量触发</strong>，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code class="language-plaintext highlighter-rouge">requestAnimationFrame</code>或<code class="language-plaintext highlighter-rouge">setTimeout</code>控制该事件的触发频率，然后可以结合<code class="language-plaintext highlighter-rouge">customEvent</code>抛出一个新事件。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">throttle</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 节流函数 控制触发频率</span>
    <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">obj</span> <span class="o">||</span> <span class="nb">window</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">running</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">func</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">running</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
      <span class="nx">running</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">requestAnimationFrame</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 结合此方法控制在每秒60次</span>
        <span class="nx">obj</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="nx">name</span><span class="p">));</span>
        <span class="nx">running</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">};</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">func</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="c1">// 将 scroll 事件重定义为 optimizedScroll 事件</span>
  <span class="nx">throttle</span><span class="p">(</span><span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">optimizedScroll</span><span class="dl">'</span><span class="p">);</span>
<span class="p">})();</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">optimizedScroll</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Resource conscious scroll callback!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">throttle</code>函数用于控制事件触发频率，<code class="language-plaintext highlighter-rouge">requestAnimationFrame</code>方法保证每次页面重绘（每秒60次），只会触发一次<code class="language-plaintext highlighter-rouge">scroll</code>事件的监听函数。也就是说，上面方法将<code class="language-plaintext highlighter-rouge">scroll</code>事件的触发频率，限制在每秒60次。具体来说，就是<code class="language-plaintext highlighter-rouge">scroll</code>事件只要频率低于每秒60次，就会触发<code class="language-plaintext highlighter-rouge">optimizedScroll</code>事件，从而执行<code class="language-plaintext highlighter-rouge">optimizedScroll</code>事件的监听函数。</p>

<p>改用<code class="language-plaintext highlighter-rouge">setTimeout</code>方法，可以放置更大的时间间隔。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span><span class="p">,</span> <span class="nx">scrollThrottler</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">scrollTimeout</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">scrollThrottler</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">scrollTimeout</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">scrollTimeout</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">scrollTimeout</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="nx">actualScrollHandler</span><span class="p">();</span>
      <span class="p">},</span> <span class="mi">66</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">actualScrollHandler</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}());</span>
</code></pre></div></div>

<p>上面代码中，每次<code class="language-plaintext highlighter-rouge">scroll</code>事件都会执行<code class="language-plaintext highlighter-rouge">scrollThrottler</code>函数。该函数里面有一个定时器<code class="language-plaintext highlighter-rouge">setTimeout</code>，每66毫秒触发一次（每秒15次）真正执行的任务<code class="language-plaintext highlighter-rouge">actualScrollHandler</code>。</p>

<p>下面是一个更一般的<code class="language-plaintext highlighter-rouge">throttle</code>函数的写法。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">wait</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">time</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="nx">time</span> <span class="o">+</span> <span class="nx">wait</span> <span class="o">-</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">fn</span><span class="p">();</span>
      <span class="nx">time</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span><span class="p">,</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>
</code></pre></div></div>

<p>上面的代码将<code class="language-plaintext highlighter-rouge">scroll</code>事件的触发频率，限制在一秒一次。</p>

<p><a href="https://www.lodashjs.com/">lodash</a>函数库提供了现成的<code class="language-plaintext highlighter-rouge">throttle</code>函数，可以直接使用。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span><span class="p">,</span> <span class="nx">_</span><span class="p">.</span><span class="nx">throttle</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>
</code></pre></div></div>

<p>本书前面介绍过<code class="language-plaintext highlighter-rouge">debounce</code>的概念，<code class="language-plaintext highlighter-rouge">throttle</code>与它区别在于，<code class="language-plaintext highlighter-rouge">throttle</code>是“节流”，确保一段时间内只执行一次，而<code class="language-plaintext highlighter-rouge">debounce</code>是“防抖”，要连续操作结束后再执行。以网页滚动为例，<code class="language-plaintext highlighter-rouge">debounce</code>要等到用户停止滚动后才执行，<code class="language-plaintext highlighter-rouge">throttle</code>则是如果用户一直在滚动网页，那么在滚动过程中还是会执行。</p>

<h4 id="42-resize-事件窗口大小变化时触发">4.2 resize 事件（窗口大小变化时触发）</h4>

<p><code class="language-plaintext highlighter-rouge">resize</code>事件<strong>在改变浏览器窗口大小时触发</strong>，主要<strong>发生在<code class="language-plaintext highlighter-rouge">window</code>对象上面</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">resizeMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">clientWidth</span> <span class="o">&lt;</span> <span class="mi">768</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">移动设备的视口</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">resize</span><span class="dl">'</span><span class="p">,</span> <span class="nx">resizeMethod</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</code></pre></div></div>

<p>该事件也会连续地大量触发，所以最好像上面的<code class="language-plaintext highlighter-rouge">scroll</code>事件一样，通过<code class="language-plaintext highlighter-rouge">throttle</code>函数控制事件触发频率。</p>

<h4 id="43-fullscreenchange-事件元素进入退出全屏时触发fullscreenerror-事件无法切换全屏时触发">4.3 fullscreenchange 事件（元素进入/退出全屏时触发），fullscreenerror 事件（无法切换全屏时触发）</h4>

<p><code class="language-plaintext highlighter-rouge">fullscreenchange</code>事件<strong>在元素进入或退出全屏状态时触发</strong>，该事件<strong>发生在<code class="language-plaintext highlighter-rouge">document</code>对象上面</strong>。</p>

<p><strong>注意，此事件非浏览器的进入/退出全屏时触发的事件。</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">fullscreenchange</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">fullscreenElement</span><span class="p">);</span> <span class="c1">// 全屏的元素，如果为null时表示已退出全屏</span>
<span class="p">});</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">).</span><span class="nx">requestFullscreen</span><span class="p">();</span> <span class="c1">// 设置元素为全屏展示</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">fullscreenerror</code>事件在<strong>浏览器无法切换到全屏状态时触发</strong>。</p>

<h3 id="5剪贴板事件">5、剪贴板事件</h3>

<p>以下三个事件属于剪贴板操作的相关事件。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。<strong>【剪切】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">copy</code>：进行复制动作时触发。<strong>【拷贝】</strong></li>
  <li><code class="language-plaintext highlighter-rouge">paste</code>：剪贴板内容粘贴到文档后触发。<strong>【粘贴】</strong></li>
</ul>

<p>这三个事件都是<strong><code class="language-plaintext highlighter-rouge">ClipboardEvent</code>接口的实例</strong>。<code class="language-plaintext highlighter-rouge">ClipboardEvent</code>有一个实例属性<code class="language-plaintext highlighter-rouge">clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《拖拉事件》的 DataTransfer 对象部分。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">clipboardData</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello, world!</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">clipboardData</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/html</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&lt;b&gt;Hello, world!&lt;/b&gt;</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p>

<h3 id="6焦点事件">6、焦点事件</h3>

<p>焦点事件发生在元素节点和<code class="language-plaintext highlighter-rouge">document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">focus</code>：元素节点<strong>获得焦点</strong>后触发，该事件不会冒泡。</li>
  <li><code class="language-plaintext highlighter-rouge">blur</code>：元素节点<strong>失去焦点</strong>后触发，该事件不会冒泡。</li>
  <li><code class="language-plaintext highlighter-rouge">focusin</code>：元素节点<strong>将要获得焦点</strong>时触发，发生在<code class="language-plaintext highlighter-rouge">focus</code>事件之前。该事件会冒泡。</li>
  <li><code class="language-plaintext highlighter-rouge">focusout</code>：元素节点<strong>将要失去焦点</strong>时触发，发生在<code class="language-plaintext highlighter-rouge">blur</code>事件之前。该事件会冒泡。</li>
</ul>

<p>这四个事件都继承了<code class="language-plaintext highlighter-rouge">FocusEvent</code>接口。<code class="language-plaintext highlighter-rouge">FocusEvent</code>实例具有以下属性。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FocusEvent.target</code>：事件的目标节点。</li>
  <li><code class="language-plaintext highlighter-rouge">FocusEvent.relatedTarget</code>：对于<code class="language-plaintext highlighter-rouge">focusin</code>事件，返回失去焦点的节点；对于<code class="language-plaintext highlighter-rouge">focusout</code>事件，返回将要接受焦点的节点；对于<code class="language-plaintext highlighter-rouge">focus</code>和<code class="language-plaintext highlighter-rouge">blur</code>事件，返回<code class="language-plaintext highlighter-rouge">null</code>。</li>
</ul>

<p>由于<code class="language-plaintext highlighter-rouge">focus</code>和<code class="language-plaintext highlighter-rouge">blur</code>事件不会冒泡，只能在捕获阶段触发，所以<code class="language-plaintext highlighter-rouge">addEventListener</code>方法的第三个参数需要设为<code class="language-plaintext highlighter-rouge">true</code>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">form</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">focus</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">pink</span><span class="dl">'</span><span class="p">;</span>
<span class="p">},</span> <span class="kc">true</span><span class="p">);</span>

<span class="nx">form</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">blur</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span>
<span class="p">},</span> <span class="kc">true</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码针对表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色。</p>

<h3 id="7customevent-接口自定义事件">7、CustomEvent 接口（自定义事件）</h3>

<p>CustomEvent 接口<strong>用于生成自定义的事件实例</strong>。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>

<p>浏览器原生提供<code class="language-plaintext highlighter-rouge">CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code class="language-plaintext highlighter-rouge">CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">detail</code>：表示事件的附带数据，默认为<code class="language-plaintext highlighter-rouge">null</code>。</li>
</ul>

<p>下面是一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">build</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="dl">'</span><span class="s1">detail</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span> <span class="p">});</span>

<span class="kd">function</span> <span class="nx">eventHandler</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">detail</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">build</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">detail</span><span class="p">);</span>
<span class="p">});</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码中，我们手动定义了<code class="language-plaintext highlighter-rouge">build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code class="language-plaintext highlighter-rouge">detail</code>属性（即字符串<code class="language-plaintext highlighter-rouge">hello</code>）。</p>

<p>下面是另一个例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">myEvent</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CustomEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">myevent</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">detail</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span>
  <span class="p">},</span>
  <span class="na">bubbles</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">cancelable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">myevent</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">detail</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">el</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="nx">myEvent</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code class="language-plaintext highlighter-rouge">detail</code>属性。</p>

<h2 id="十一globaleventhandlers-接口-全局事件处理接口">十一、GlobalEventHandlers 接口 （全局事件处理接口）</h2>

<p>指定事件的回调函数，推荐使用的方法是元素的<code class="language-plaintext highlighter-rouge">addEventListener</code>方法。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">div</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">clickHandler</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div>

<p>除了之外，还有一种方法可以直接指定事件的回调函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">div</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="nx">clickHandler</span><span class="p">;</span>
</code></pre></div></div>

<p>这个接口是由<code class="language-plaintext highlighter-rouge">GlobalEventHandlers</code>接口提供的。它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。</p>

<p><strong><code class="language-plaintext highlighter-rouge">HTMLElement</code>、<code class="language-plaintext highlighter-rouge">Document</code>和<code class="language-plaintext highlighter-rouge">Window</code>都继承了这个接口，也就是说，各种 HTML 元素、<code class="language-plaintext highlighter-rouge">document</code>对象、<code class="language-plaintext highlighter-rouge">window</code>对象上面都可以使用<code class="language-plaintext highlighter-rouge">GlobalEventHandlers</code>接口提供的属性</strong>。下面就列出这个接口提供的主要的事件属性。</p>

<h3 id="1globaleventhandlersonabort-中断事件">1、GlobalEventHandlers.onabort （中断事件）</h3>

<p>某个对象的<code class="language-plaintext highlighter-rouge">abort</code>事件（停止加载）发生时，就会调用<code class="language-plaintext highlighter-rouge">onabort</code>属性指定的回调函数。</p>

<p>各种元素的停止加载事件，到底如何触发，目前并没有统一的规定。因此实际上，这个属性现在一般只用在<code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>元素上面。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// HTML 代码如下</span>
<span class="c1">// &lt;img src="example.jpg" id="img"&gt;</span>
<span class="kd">var</span> <span class="nx">img</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">img</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">onabort</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">图片加载中断</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2globaleventhandlersonerror-错误事件">2、GlobalEventHandlers.onerror （错误事件）</h3>

<p><code class="language-plaintext highlighter-rouge">error</code>事件发生时，就会调用<code class="language-plaintext highlighter-rouge">onerror</code>属性指定的回调函数。</p>

<p><code class="language-plaintext highlighter-rouge">error</code>事件<strong>分成两种</strong>。</p>

<p><strong>一种是 JavaScript 的运行时错误</strong>，这会传到<code class="language-plaintext highlighter-rouge">window</code>对象，导致<code class="language-plaintext highlighter-rouge">window.onerror()</code>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">lineno</span><span class="p">,</span> <span class="nx">colno</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">window.onerror</code>的处理函数共接受五个参数，含义如下。</p>

<ul>
  <li>message：错误信息字符串</li>
  <li>source：报错脚本的 URL</li>
  <li>lineno：报错的行号，是一个整数</li>
  <li>colno：报错的列号，是一个整数</li>
  <li>error： 错误对象</li>
</ul>

<p>另<strong>一种是资源加载错误</strong>，比如<code class="language-plaintext highlighter-rouge">  &lt;img&gt;  </code>或<code class="language-plaintext highlighter-rouge">  &lt;script&gt;  </code>加载的资源出现加载错误。这时，Error 对象会传到对应的元素，导致该元素的<code class="language-plaintext highlighter-rouge">onerror</code>属性开始执行。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">element</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意，一般来说，资源的加载错误不会触发<code class="language-plaintext highlighter-rouge">window.onerror</code>。</p>

<h3 id="3globaleventhandlersonload加载完成事件globaleventhandlersonloadstart开始加载事件">3、GlobalEventHandlers.onload（加载完成事件）、GlobalEventHandlers.onloadstart（开始加载事件）</h3>

<p>元素完成加载时，会触发<code class="language-plaintext highlighter-rouge">load</code>事件，执行<code class="language-plaintext highlighter-rouge">onload()</code>。它的典型使用场景是<code class="language-plaintext highlighter-rouge">window</code>对象和<code class="language-plaintext highlighter-rouge">  &lt;img&gt;  </code>元素。对于<code class="language-plaintext highlighter-rouge">window</code>对象来说，只有页面的所有资源加载完成（包括图片、脚本、样式表、字体等所有外部资源），才会触发<code class="language-plaintext highlighter-rouge">load</code>事件。</p>

<p>对于<code class="language-plaintext highlighter-rouge">  &lt;img&gt;  </code>和<code class="language-plaintext highlighter-rouge">  &lt;video&gt;  </code>等元素，加载开始时还会触发<code class="language-plaintext highlighter-rouge">loadstart</code>事件，导致执行<code class="language-plaintext highlighter-rouge">onloadstart</code>。</p>

<h3 id="4globaleventhandlersonfocus获取焦点事件globaleventhandlersonblur失去焦点事件">4、GlobalEventHandlers.onfocus（获取焦点事件），GlobalEventHandlers.onblur（失去焦点事件）</h3>

<p>当前元素获得焦点时，会触发<code class="language-plaintext highlighter-rouge">element.onfocus</code>；失去焦点时，会触发<code class="language-plaintext highlighter-rouge">element.onblur</code>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">element</span><span class="p">.</span><span class="nx">onfocus</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">onfocus event detected!</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">onblur</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">onblur event detected!</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>注意，如果不是可以接受用户输入的元素，要触发<code class="language-plaintext highlighter-rouge">onfocus</code>，该元素必须有<code class="language-plaintext highlighter-rouge">tabindex</code>属性。</p>

<h3 id="5globaleventhandlersonscroll滚动事件">5、GlobalEventHandlers.onscroll（滚动事件）</h3>

<p>页面或元素滚动时，会触发<code class="language-plaintext highlighter-rouge">scroll</code>事件，导致执行<code class="language-plaintext highlighter-rouge">onscroll()</code>。</p>

<h3 id="6globaleventhandlersoncontextmenu右键菜单事件globaleventhandlersonshow显示右键菜单时触发">6、GlobalEventHandlers.oncontextmenu（右键菜单事件），GlobalEventHandlers.onshow（显示右键菜单时触发）</h3>

<p>用户在页面上按下鼠标的右键，会触发<code class="language-plaintext highlighter-rouge">contextmenu</code>事件，导致执行<code class="language-plaintext highlighter-rouge">oncontextmenu()</code>。如果该属性执行后返回<code class="language-plaintext highlighter-rouge">false</code>，就等于禁止了右键菜单。<code class="language-plaintext highlighter-rouge">document.oncontextmenu</code>与<code class="language-plaintext highlighter-rouge">window.oncontextmenu</code>效果一样。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">oncontextmenu</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span><span class="c1">// 禁用右键菜单</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上面代码中，<code class="language-plaintext highlighter-rouge">oncontextmenu</code>属性执行后返回<code class="language-plaintext highlighter-rouge">false</code>，右键菜单就不会出现。</p>

<p>元素的右键菜单显示时，会触发该元素的<code class="language-plaintext highlighter-rouge">onshow</code>监听函数。</p>

<h3 id="7其他的事件属性">7、其他的事件属性</h3>

<p>鼠标的事件属性。</p>

<ul>
  <li>onclick</li>
  <li>ondblclick</li>
  <li>onmousedown</li>
  <li>onmouseenter</li>
  <li>onmouseleave</li>
  <li>onmousemove</li>
  <li>onmouseout</li>
  <li>onmouseover</li>
  <li>onmouseup</li>
  <li>onwheel</li>
</ul>

<p>键盘的事件属性。</p>

<ul>
  <li>onkeydown</li>
  <li>onkeypress</li>
  <li>onkeyup</li>
</ul>

<p>焦点的事件属性。</p>

<ul>
  <li>onblur</li>
  <li>onfocus</li>
</ul>

<p>表单的事件属性。</p>

<ul>
  <li>oninput</li>
  <li>onchange</li>
  <li>onsubmit</li>
  <li>onreset</li>
  <li>oninvalid</li>
  <li>onselect</li>
</ul>

<p>触摸的事件属性。</p>

<ul>
  <li>ontouchcancel</li>
  <li>ontouchend</li>
  <li>ontouchmove</li>
  <li>ontouchstart</li>
</ul>

<p>拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。</p>

<p>被拖动元素的事件属性。</p>

<ul>
  <li>ondragstart：拖动开始</li>
  <li>ondrag：拖动过程中，每隔几百毫秒触发一次</li>
  <li>ondragend：拖动结束</li>
</ul>

<p>接收被拖动元素的容器元素的事件属性。</p>

<ul>
  <li>ondragenter：被拖动元素进入容器元素。</li>
  <li>ondragleave：被拖动元素离开容器元素。</li>
  <li>ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。</li>
  <li>ondrop：松开鼠标后，被拖动元素放入容器元素。</li>
</ul>

<p>` <dialog> `对话框元素的事件属性。</dialog></p>

<ul>
  <li>oncancel</li>
  <li>onclose</li>
</ul>

<h2 id="文档">文档</h2>

<p>学习文档：<a href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p>
