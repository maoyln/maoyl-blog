<p>拦截器设计与实现</p>

<h2 id="需求分析">需求分析</h2>

<p>我们希望能对请求的发送和响应做拦截，也就是在发送请求之前和接收到响应之后做一些额外逻辑。</p>

<p>我们希望设计的拦截器的使用方式如下：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 添加一个请求拦截器</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 在发送请求之前可以做一些事情</span>
  <span class="k">return</span> <span class="nx">config</span><span class="p">;</span>
<span class="p">},</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理请求错误</span>
  <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// 添加一个响应拦截器</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理响应数据</span>
  <span class="k">return</span> <span class="nx">response</span><span class="p">;</span>
<span class="p">},</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理响应错误</span>
  <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">axios</code> 对象上有一个 <code class="language-plaintext highlighter-rouge">interceptors</code> 对象属性，该属性又有 <code class="language-plaintext highlighter-rouge">request</code> 和 <code class="language-plaintext highlighter-rouge">response</code> 2 个属性，它们都有一个 <code class="language-plaintext highlighter-rouge">use</code> 方法，<code class="language-plaintext highlighter-rouge">use</code> 方法支持 2 个参数，第一个参数类似 Promise 的 <code class="language-plaintext highlighter-rouge">resolve</code> 函数，第二个参数类似 Promise 的 <code class="language-plaintext highlighter-rouge">reject</code> 函数。我们可以在 <code class="language-plaintext highlighter-rouge">resolve</code> 函数和 <code class="language-plaintext highlighter-rouge">reject</code> 函数中执行同步代码或者是异步代码逻辑。</p>

<p>并且我们是可以添加多个拦截器的，拦截器的执行顺序是链式依次执行的方式。对于 <code class="language-plaintext highlighter-rouge">request</code> 拦截器，后添加的拦截器会在请求前的过程中先执行；对于 <code class="language-plaintext highlighter-rouge">response</code> 拦截器，先添加的拦截器会在响应后先执行。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">config</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">config</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">test</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">config</span>
<span class="p">})</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">config</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">config</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">test</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">config</span>
<span class="p">})</span>
</code></pre></div></div>

<p>此外，我们也可以支持删除某个拦截器，如下：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">myInterceptor</span> <span class="o">=</span> <span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span><span class="cm">/*...*/</span><span class="p">})</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">eject</span><span class="p">(</span><span class="nx">myInterceptor</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="整体设计">整体设计</h2>

<p>我们先用一张图来展示一下拦截器工作流程：</p>

<p><img src="https://cdn.jsdelivr.net/gh/maoyln/maoyl-img/blog/20200105110744.png" alt="interceptor" title="interceptor" /></p>

<p>整个过程是一个链式调用的方式，并且每个拦截器都可以支持同步和异步处理，我们自然而然地就联想到使用 Promise 链的方式来实现整个调用过程。</p>

<p>在这个 Promise 链的执行过程中，请求拦截器 <code class="language-plaintext highlighter-rouge">resolve</code> 函数处理的是 <code class="language-plaintext highlighter-rouge">config</code> 对象，而相应拦截器 <code class="language-plaintext highlighter-rouge">resolve</code> 函数处理的是 <code class="language-plaintext highlighter-rouge">response</code> 对象。</p>

<p>在了解了拦截器工作流程后，我们先要创建一个拦截器管理类，允许我们去添加
删除和遍历拦截器。</p>

<h2 id="拦截器管理类实现">拦截器管理类实现</h2>

<p>根据需求，<code class="language-plaintext highlighter-rouge">axios</code> 拥有一个 <code class="language-plaintext highlighter-rouge">interceptors</code> 对象属性，该属性又有 <code class="language-plaintext highlighter-rouge">request</code> 和 <code class="language-plaintext highlighter-rouge">response</code> 2 个属性，它们对外提供一个 <code class="language-plaintext highlighter-rouge">use</code> 方法来添加拦截器，我们可以把这俩属性看做是一个拦截器管理对象。<code class="language-plaintext highlighter-rouge">use</code> 方法支持 2 个参数，第一个是 <code class="language-plaintext highlighter-rouge">resolve</code> 函数，第二个是 <code class="language-plaintext highlighter-rouge">reject</code> 函数，对于 <code class="language-plaintext highlighter-rouge">resolve</code> 函数的参数，请求拦截器是 <code class="language-plaintext highlighter-rouge">AxiosRequestConfig</code> 类型的，而响应拦截器是 <code class="language-plaintext highlighter-rouge">AxiosResponse</code> 类型的；而对于 <code class="language-plaintext highlighter-rouge">reject</code> 函数的参数类型则是 <code class="language-plaintext highlighter-rouge">any</code> 类型的。</p>

<p>根据上述分析，我们先来定义一下拦截器管理对象对外的接口。</p>

<h3 id="接口定义">接口定义</h3>

<p><code class="language-plaintext highlighter-rouge">types/index.ts</code>：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kr">interface</span> <span class="nx">AxiosInterceptorManager</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">use</span><span class="p">(</span><span class="na">resolved</span><span class="p">:</span> <span class="nx">ResolvedFn</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">rejected</span><span class="p">?:</span> <span class="nx">RejectedFn</span><span class="p">):</span> <span class="kr">number</span>

  <span class="nx">eject</span><span class="p">(</span><span class="na">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kr">interface</span> <span class="nx">ResolvedFn</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">=</span><span class="kr">any</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">(</span><span class="na">val</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kr">interface</span> <span class="nx">RejectedFn</span> <span class="p">{</span>
  <span class="p">(</span><span class="nx">error</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="kr">any</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里我们定义了 <code class="language-plaintext highlighter-rouge">AxiosInterceptorManager</code> 泛型接口，因为对于 <code class="language-plaintext highlighter-rouge">resolve</code> 函数的参数，请求拦截器和响应拦截器是不同的。</p>

<h3 id="代码实现">代码实现</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">ResolvedFn</span><span class="p">,</span> <span class="nx">RejectedFn</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../types</span><span class="dl">'</span>

<span class="kr">interface</span> <span class="nx">Interceptor</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">resolved</span><span class="p">:</span> <span class="nx">ResolvedFn</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
  <span class="nx">rejected</span><span class="p">?:</span> <span class="nx">RejectedFn</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">InterceptorManager</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="na">interceptors</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Interceptor</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="o">&gt;</span>

  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">interceptors</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>

  <span class="nx">use</span><span class="p">(</span><span class="na">resolved</span><span class="p">:</span> <span class="nx">ResolvedFn</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">rejected</span><span class="p">?:</span> <span class="nx">RejectedFn</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
      <span class="nx">resolved</span><span class="p">,</span>
      <span class="nx">rejected</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="p">}</span>

  <span class="nx">forEach</span><span class="p">(</span><span class="na">fn</span><span class="p">:</span> <span class="p">(</span><span class="na">interceptor</span><span class="p">:</span> <span class="nx">Interceptor</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">interceptor</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">interceptor</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fn</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="nx">eject</span><span class="p">(</span><span class="na">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">[</span><span class="nx">id</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们定义了一个 <code class="language-plaintext highlighter-rouge">InterceptorManager</code> 泛型类，内部维护了一个私有属性 <code class="language-plaintext highlighter-rouge">interceptors</code>，它是一个数组，用来存储拦截器。该类还对外提供了 3 个方法，其中 <code class="language-plaintext highlighter-rouge">use</code> 接口就是添加拦截器到 <code class="language-plaintext highlighter-rouge">interceptors</code> 中，并返回一个 <code class="language-plaintext highlighter-rouge">id</code> 用于删除；<code class="language-plaintext highlighter-rouge">forEach</code> 接口就是遍历 <code class="language-plaintext highlighter-rouge">interceptors</code> 用的，它支持传入一个函数，遍历过程中会调用该函数，并把每一个 <code class="language-plaintext highlighter-rouge">interceptor</code> 作为该函数的参数传入；<code class="language-plaintext highlighter-rouge">eject</code> 就是删除一个拦截器，通过传入拦截器的 <code class="language-plaintext highlighter-rouge">id</code> 删除。</p>

<h2 id="链式调用实现">链式调用实现</h2>

<blockquote>
  <p>本小节需要你对 Promise 掌握和理解，可以前往 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">mdn</a> 学习。</p>
</blockquote>

<p>当我们实现好拦截器管理类，接下来就是在 <code class="language-plaintext highlighter-rouge">Axios</code> 中定义一个 <code class="language-plaintext highlighter-rouge">interceptors</code> 属性，它的类型如下：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Interceptors</span> <span class="p">{</span>
  <span class="nl">request</span><span class="p">:</span> <span class="nx">InterceptorManager</span><span class="o">&lt;</span><span class="nx">AxiosRequestConfig</span><span class="o">&gt;</span>
  <span class="nx">response</span><span class="p">:</span> <span class="nx">InterceptorManager</span><span class="o">&lt;</span><span class="nx">AxiosResponse</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">Axios</span> <span class="p">{</span>
  <span class="nl">interceptors</span><span class="p">:</span> <span class="nx">Interceptors</span>

  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">interceptors</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">request</span><span class="p">:</span> <span class="k">new</span> <span class="nx">InterceptorManager</span><span class="o">&lt;</span><span class="nx">AxiosRequestConfig</span><span class="o">&gt;</span><span class="p">(),</span>
      <span class="na">response</span><span class="p">:</span> <span class="k">new</span> <span class="nx">InterceptorManager</span><span class="o">&lt;</span><span class="nx">AxiosResponse</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Interceptors</code> 类型拥有 2 个属性，一个请求拦截器管理类实例，一个是响应拦截器管理类实例。我们在实例化 <code class="language-plaintext highlighter-rouge">Axios</code> 类的时候，在它的构造器去初始化这个 <code class="language-plaintext highlighter-rouge">interceptors</code> 实例属性。</p>

<p>接下来，我们修改 <code class="language-plaintext highlighter-rouge">request</code> 方法的逻辑，添加拦截器链式调用的逻辑：</p>

<p><code class="language-plaintext highlighter-rouge">core/Axios.ts</code>：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">PromiseChain</span> <span class="p">{</span>
  <span class="nl">resolved</span><span class="p">:</span> <span class="nx">ResolvedFn</span> <span class="o">|</span> <span class="p">((</span><span class="nx">config</span><span class="p">:</span> <span class="nx">AxiosRequestConfig</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">AxiosPromise</span><span class="p">)</span>
  <span class="nx">rejected</span><span class="p">?:</span> <span class="nx">RejectedFn</span>
<span class="p">}</span>

<span class="nx">request</span><span class="p">(</span><span class="nx">url</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">config</span><span class="p">?:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">AxiosPromise</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">url</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">config</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="nx">config</span><span class="p">.</span><span class="nx">url</span> <span class="o">=</span> <span class="nx">url</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">config</span> <span class="o">=</span> <span class="nx">url</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">chain</span><span class="p">:</span> <span class="nx">PromiseChain</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[{</span>
    <span class="na">resolved</span><span class="p">:</span> <span class="nx">dispatchRequest</span><span class="p">,</span>
    <span class="na">rejected</span><span class="p">:</span> <span class="kc">undefined</span>
  <span class="p">}]</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">interceptor</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">chain</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">interceptor</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">chain</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">config</span><span class="p">)</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">chain</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">resolved</span><span class="p">,</span> <span class="nx">rejected</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span><span class="o">!</span>
    <span class="nx">promise</span> <span class="o">=</span> <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">resolved</span><span class="p">,</span> <span class="nx">rejected</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">promise</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先，构造一个 <code class="language-plaintext highlighter-rouge">PromiseChain</code> 类型的数组 <code class="language-plaintext highlighter-rouge">chain</code>，并把 <code class="language-plaintext highlighter-rouge">dispatchRequest</code> 函数赋值给 <code class="language-plaintext highlighter-rouge">resolved</code> 属性；接着先遍历请求拦截器插入到 <code class="language-plaintext highlighter-rouge">chain</code> 的前面；然后再遍历响应拦截器插入到 <code class="language-plaintext highlighter-rouge">chain</code> 后面。</p>

<p>接下来定义一个已经 resolve 的 <code class="language-plaintext highlighter-rouge">promise</code>，循环这个 <code class="language-plaintext highlighter-rouge">chain</code>，拿到每个拦截器对象，把它们的 <code class="language-plaintext highlighter-rouge">resolved</code> 函数和 <code class="language-plaintext highlighter-rouge">rejected</code> 函数添加到 <code class="language-plaintext highlighter-rouge">promise.then</code> 的参数中，这样就相当于通过 Promise 的链式调用方式，实现了拦截器一层层的链式调用的效果。</p>

<p>注意我们拦截器的执行顺序，对于请求拦截器，先执行后添加的，再执行先添加的；而对于响应拦截器，先执行先添加的，后执行后添加的。</p>

<h2 id="demo-编写">demo 编写</h2>

<p>在 <code class="language-plaintext highlighter-rouge">examples</code> 目录下创建 <code class="language-plaintext highlighter-rouge">interceptor</code> 目录，在 <code class="language-plaintext highlighter-rouge">interceptor</code> 目录下创建 <code class="language-plaintext highlighter-rouge">index.html</code>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>Interceptor example<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"/__build__/interceptor.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>接着创建 <code class="language-plaintext highlighter-rouge">app.ts</code> 作为入口文件：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">axios</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../../src/index</span><span class="dl">'</span>

<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">config</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">config</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">test</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">config</span>
<span class="p">})</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">config</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">config</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">test</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">config</span>
<span class="p">})</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">config</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">config</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">test</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">3</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">config</span>
<span class="p">})</span>

<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">data</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">})</span>
<span class="kd">let</span> <span class="nx">interceptor</span> <span class="o">=</span> <span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">data</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">})</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">data</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">3</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">})</span>

<span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">eject</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">)</span>

<span class="nx">axios</span><span class="p">({</span>
  <span class="na">url</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/interceptor/get</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">get</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">test</span><span class="p">:</span> <span class="dl">''</span>
  <span class="p">}</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p>该 demo 我们添加了 3 个请求拦截器，添加了 3 个响应拦截器并删除了第二个。运行该 demo 我们通过浏览器访问，我们发送的请求添加了一个 <code class="language-plaintext highlighter-rouge">test</code> 的请求 header，它的值是 <code class="language-plaintext highlighter-rouge">321</code>；我们的响应数据返回的是 <code class="language-plaintext highlighter-rouge">hello</code>，经过响应拦截器的处理，最终我们输出的数据是 <code class="language-plaintext highlighter-rouge">hello13</code>。</p>

<p>至此，我们给 <code class="language-plaintext highlighter-rouge">ts-axios</code> 实现了拦截器功能，它是一个非常实用的功能，在实际工作中我们可以利用它做一些需求如登录权限认证。</p>

<p>我们目前通过 <code class="language-plaintext highlighter-rouge">axios</code> 发送请求，往往会传入一堆配置，但是我们也希望 <code class="language-plaintext highlighter-rouge">ts-axios</code> 本身也会有一些默认配置，我们把用户传入的自定义配置和默认配置做一层合并。其实，大部分的 JS 库都是类似的玩法。下面一章我们就来实现这个 feature。</p>
