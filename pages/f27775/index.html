<h1 id="05-事件处理">05. 事件处理</h1>

<h2 id="与传统html绑定事件的区别">与传统HTML绑定事件的区别</h2>

<p>传统的 HTML：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"activateLasers()"</span><span class="nt">&gt;</span>
  Activate Lasers
<span class="nt">&lt;/button&gt;</span>
</code></pre></div></div>

<p>在 React 中略微不同：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1.事件名为小驼峰； 2.传入函数以大括号包裹函数名形式</span>
<span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">activateLasers</span><span class="si">}</span><span class="p">&gt;</span>
  Activate Lasers
<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</code></pre></div></div>

<ul>
  <li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>
  <li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li>
</ul>

<h3 id="阻止默认事件-合成事件对象">阻止默认事件 (合成事件对象)</h3>

<p>在 React 中，你需要这样阻止默认事件：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">ActionLink</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">handleClick</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">The link was clicked.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="p">=</span><span class="s">"#"</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
      Click me
    <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在这里，<code class="language-plaintext highlighter-rouge">e</code> 是一个<strong>合成事件</strong>。React 根据 <a href="https://www.w3.org/TR/DOM-Level-3-Events/">W3C 规范</a>来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。如果想了解更多，请查看 <a href="https://zh-hans.reactjs.org/docs/events.html"><code class="language-plaintext highlighter-rouge">SyntheticEvent</code></a> 参考指南。</p>

<h2 id="绑定事件的方式">绑定事件的方式</h2>

<p>使用 React 时，你一般不需要使用 <code class="language-plaintext highlighter-rouge">addEventListener</code> 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。</p>

<p>当你使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a> 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 <code class="language-plaintext highlighter-rouge">Toggle</code> 组件会渲染一个让用户切换开关状态的按钮：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Toggle</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span><span class="na">isToggleOn</span><span class="p">:</span> <span class="kc">true</span><span class="p">};</span>

    <span class="c1">// 为了在回调中使用 `this`，这个绑定是必不可少的</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="err">；</span>
  <span class="p">}</span>

  <span class="nx">hadleClick</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">state</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="na">isToggleOn</span><span class="p">:</span> <span class="o">!</span><span class="nx">state</span><span class="p">.</span><span class="nx">isToggleOn</span>
    <span class="p">}));</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">(){</span>
    <span class="k">return</span><span class="p">(</span>
      <span class="c1">// 为了能在这里使用 this.handleClick调用方法，因此需要在构造函数内添加handleChick属性指向回调方法 ？</span>
    	<span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isToggleOn</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">ON</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">OFF</span><span class="dl">'</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span>
	<span class="p">&lt;</span><span class="nc">Toggle</span> <span class="p">/&gt;,</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">root</span><span class="dl">'</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p>你必须谨慎对待 JSX 回调函数中的 <code class="language-plaintext highlighter-rouge">this</code>，在 JavaScript 中，class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> <code class="language-plaintext highlighter-rouge">this</code>。如果你忘记绑定 <code class="language-plaintext highlighter-rouge">this.handleClick</code> 并把它传入了 <code class="language-plaintext highlighter-rouge">onClick</code>，当你调用这个函数的时候 <code class="language-plaintext highlighter-rouge">this</code> 的值为 <code class="language-plaintext highlighter-rouge">undefined</code>。</p>

<p>这并不是 React 特有的行为；这其实与 <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/">JavaScript 函数工作原理</a>有关。通常情况下，如果你没有在方法后面添加 <code class="language-plaintext highlighter-rouge">()</code>，例如 <code class="language-plaintext highlighter-rouge">onClick={this.handleClick}</code>，你应该<strong>为这个方法绑定 <code class="language-plaintext highlighter-rouge">this</code></strong>。</p>

<p>如果觉得使用 <code class="language-plaintext highlighter-rouge">bind</code> 很麻烦，这里有两种方式可以解决。如果你正在使用实验性的 <a href="https://babeljs.io/docs/plugins/transform-class-properties/">public class fields 语法</a>，你可以使用 class fields 正确的绑定回调函数：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">LoggingButton</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="c1">// 此语法确保 `handleClick` 内的 `this` 已被绑定。</span>
  <span class="c1">// 注意: 这是 *实验性* 语法。</span>
  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">this is:</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
        Click me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="https://github.com/facebookincubator/create-react-app">Create React App</a> 默认启用此语法。</p>

<p>如果你没有使用 class fields 语法，你可以在回调中使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">LoggingButton</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">handleClick</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">this is:</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 此语法确保 `handleClick` 内的 `this` 已被绑定。</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">()</span><span class="si">}</span><span class="p">&gt;</span>
        Click me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>此语法问题在于每次渲染 <code class="language-plaintext highlighter-rouge">LoggingButton</code> 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。<strong>我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题</strong>。</p>

<h3 id="事件命名规范">事件命名规范</h3>

<p>在 React 中，有一个命名规范，通常会将代表事件的监听 prop 命名为 <code class="language-plaintext highlighter-rouge">on[Event]</code>，将处理事件的监听方法命名为 <code class="language-plaintext highlighter-rouge">handle[Event]</code> 这样的格式。</p>

<h2 id="向事件处理程序传递参数">向事件处理程序传递参数</h2>

<p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code class="language-plaintext highlighter-rouge">id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">deleteRow</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>Delete Row<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">deleteRow</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>Delete Row<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>上述两种方式是等价的，分别通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code class="language-plaintext highlighter-rouge">Function.prototype.bind</code></a> 来实现。</p>

<p>在这两种情况下，<strong>React 的事件对象 <code class="language-plaintext highlighter-rouge">e</code> 会被作为第二个参数传递</strong>。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code class="language-plaintext highlighter-rouge">bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
