<h1 id="高级类型">高级类型</h1>

<h2 id="交叉类型">交叉类型</h2>

<p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code class="language-plaintext highlighter-rouge">Person &amp; Loggable</code> 同时是 <code class="language-plaintext highlighter-rouge">Person</code> 和 <code class="language-plaintext highlighter-rouge">Loggable</code>。 就是说这个类型的对象同时拥有了这两种类型的成员。</p>

<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">extend</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span> <span class="p">(</span><span class="nx">first</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">second</span><span class="p">:</span> <span class="nx">U</span><span class="p">):</span> <span class="nx">T</span> <span class="o">&amp;</span> <span class="nx">U</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">as</span> <span class="nx">T</span> <span class="o">&amp;</span> <span class="nx">U</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">id</span> <span class="k">in</span> <span class="nx">first</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="nx">first</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="k">as</span> <span class="kr">any</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">id</span> <span class="k">in</span> <span class="nx">second</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">result</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="nx">second</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="k">as</span> <span class="kr">any</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="kd">constructor</span> <span class="p">(</span><span class="k">public</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Loggable</span> <span class="p">{</span>
  <span class="nx">log</span> <span class="p">():</span> <span class="k">void</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">ConsoleLogger</span> <span class="k">implements</span> <span class="nx">Loggable</span> <span class="p">{</span>
  <span class="nx">log</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">jim</span> <span class="o">=</span> <span class="nx">extend</span><span class="p">(</span><span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">Jim</span><span class="dl">'</span><span class="p">),</span> <span class="k">new</span> <span class="nx">ConsoleLogger</span><span class="p">())</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">jim</span><span class="p">.</span><span class="nx">name</span>
<span class="nx">jim</span><span class="p">.</span><span class="nx">log</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="联合类型">联合类型</h2>

<p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code class="language-plaintext highlighter-rouge">number</code> 或 <code class="language-plaintext highlighter-rouge">string</code> 类型的参数。 例如下面的函数：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">padLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">any</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">padding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span> <span class="nx">value</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">padding</span> <span class="o">+</span> <span class="nx">value</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Expected string or number, got '</span><span class="p">${</span><span class="nx">padding</span><span class="p">}</span><span class="s2">'.`</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">padLeft</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello world</span><span class="dl">'</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// returns "    Hello world"</span>

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">padLeft</code> 存在一个问题，<code class="language-plaintext highlighter-rouge">padding</code> 参数的类型指定成了 <code class="language-plaintext highlighter-rouge">any</code>。 这就是说我们可以传入一个既不是 <code class="language-plaintext highlighter-rouge">number</code> 也不是 <code class="language-plaintext highlighter-rouge">string</code> 类型的参数，但是 TypeScript 却不报错。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">indentedString</span> <span class="o">=</span> <span class="nx">padLeft</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello world</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// 编译阶段通过，运行时报错</span>
</code></pre></div></div>

<p>为了解决这个问题，我们可以使用 联合类型做为 <code class="language-plaintext highlighter-rouge">padding</code> 的参数：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">padLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">indentedString</span> <span class="o">=</span> <span class="nx">padLeft</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello world</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// 编译阶段报错</span>
</code></pre></div></div>

<p>联合类型表示一个值可以是几种类型之一。我们用竖线（<code class="language-plaintext highlighter-rouge">|</code>）分隔每个类型，所以 <code class="language-plaintext highlighter-rouge">number | string</code> 表示一个值可以是 <code class="language-plaintext highlighter-rouge">number</code> 或 <code class="language-plaintext highlighter-rouge">string</code>。</p>

<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Bird</span> <span class="p">{</span>
  <span class="nx">fly</span><span class="p">()</span>
  <span class="nx">layEggs</span><span class="p">()</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Fish</span> <span class="p">{</span>
  <span class="nx">swim</span><span class="p">()</span>
  <span class="nx">layEggs</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getSmallPet</span><span class="p">():</span> <span class="nx">Fish</span> <span class="o">|</span> <span class="nx">Bird</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">pet</span> <span class="o">=</span> <span class="nx">getSmallPet</span><span class="p">()</span>
<span class="nx">pet</span><span class="p">.</span><span class="nx">layEggs</span><span class="p">()</span> <span class="c1">// okay</span>
<span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">()</span>    <span class="c1">// error</span>
</code></pre></div></div>

<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code class="language-plaintext highlighter-rouge">A | B</code>，我们能够确定的是它包含了 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 中共有的成员。这个例子里，<code class="language-plaintext highlighter-rouge">Fish</code> 具有一个 <code class="language-plaintext highlighter-rouge">swim</code> 方法，我们不能确定一个 <code class="language-plaintext highlighter-rouge">Bird | Fish</code> 类型的变量是否有 <code class="language-plaintext highlighter-rouge">swim</code>方法。 如果变量在运行时是 <code class="language-plaintext highlighter-rouge">Bird</code> 类型，那么调用 <code class="language-plaintext highlighter-rouge">pet.swim()</code> 就出错了。</p>

<h2 id="类型保护">类型保护</h2>

<p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 <code class="language-plaintext highlighter-rouge">Fish</code> 或者是 <code class="language-plaintext highlighter-rouge">Bird</code> 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">pet</span> <span class="o">=</span> <span class="nx">getSmallPet</span><span class="p">()</span>

<span class="c1">// 每一个成员访问都会报错</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">()</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">pet</span><span class="p">.</span><span class="nx">fly</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">pet</span><span class="p">.</span><span class="nx">fly</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了让这段代码工作，我们要使用类型断言：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">pet</span> <span class="o">=</span> <span class="nx">getSmallPet</span><span class="p">()</span>

<span class="k">if</span> <span class="p">((</span><span class="nx">pet</span> <span class="k">as</span> <span class="nx">Fish</span><span class="p">).</span><span class="nx">swim</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="nx">pet</span> <span class="k">as</span> <span class="nx">Fish</span><span class="p">).</span><span class="nx">swim</span><span class="p">()</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="p">(</span><span class="nx">pet</span> <span class="k">as</span> <span class="nx">Bird</span><span class="p">).</span><span class="nx">fly</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="用户自定义的类型保护">用户自定义的类型保护</h3>

<p>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code class="language-plaintext highlighter-rouge">pet</code> 的类型的话就好了。</p>

<p>TypeScript 里的<em>类型保护</em>机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个<em>类型谓词</em>：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">isFish</span><span class="p">(</span><span class="nx">pet</span><span class="p">:</span> <span class="nx">Fish</span> <span class="o">|</span> <span class="nx">Bird</span><span class="p">):</span> <span class="nx">pet</span> <span class="k">is</span> <span class="nx">Fish</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">pet</span> <span class="k">as</span> <span class="nx">Fish</span><span class="p">).</span><span class="nx">swim</span> <span class="o">!==</span> <span class="kc">undefined</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在这个例子里，<code class="language-plaintext highlighter-rouge">pet is Fish</code> 就是类型谓词。谓词为 <code class="language-plaintext highlighter-rouge">parameterName is Type</code> 这种形式， <code class="language-plaintext highlighter-rouge">parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>

<p>每当使用一些变量调用 <code class="language-plaintext highlighter-rouge">isFish</code> 时，<code class="language-plaintext highlighter-rouge">TypeScript</code> 会将变量缩减为那个具体的类型。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">isFish</span><span class="p">(</span><span class="nx">pet</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="nx">pet</span><span class="p">.</span><span class="nx">fly</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意 <code class="language-plaintext highlighter-rouge">TypeScript</code> 不仅知道在 <code class="language-plaintext highlighter-rouge">if</code> 分支里 <code class="language-plaintext highlighter-rouge">pet</code> 是 <code class="language-plaintext highlighter-rouge">Fish</code> 类型；它还清楚在 <code class="language-plaintext highlighter-rouge">else</code> 分支里，一定不是 Fish类型而是 <code class="language-plaintext highlighter-rouge">Bird</code> 类型。</p>

<h3 id="typeof-类型保护">typeof 类型保护</h3>

<p>现在我们回过头来看看怎么使用联合类型书写 <code class="language-plaintext highlighter-rouge">padLeft</code> 代码。我们可以像下面这样利用类型断言来写：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">isNumber</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span><span class="nx">x</span> <span class="k">is</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">isString</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">x</span> <span class="k">is</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">padLeft</span> <span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">padding</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">padding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span> <span class="nx">value</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isString</span><span class="p">(</span><span class="nx">padding</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">padding</span> <span class="o">+</span> <span class="nx">value</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Expected string or number, got '</span><span class="p">${</span><span class="nx">padding</span><span class="p">}</span><span class="s2">'.`</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code class="language-plaintext highlighter-rouge">typeof x === 'number' </code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">padLeft</span> <span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">padding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span> <span class="nx">value</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">padding</span> <span class="o">+</span> <span class="nx">value</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Expected string or number, got '</span><span class="p">${</span><span class="nx">padding</span><span class="p">}</span><span class="s2">'.`</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这些 <code class="language-plaintext highlighter-rouge">typeof</code> 类型保护只有两种形式能被识别：<code class="language-plaintext highlighter-rouge">typeof v === "typename"</code> 和 <code class="language-plaintext highlighter-rouge">typeof v !== "typename"</code>， <code class="language-plaintext highlighter-rouge">"typename"</code>必须是 <code class="language-plaintext highlighter-rouge">"number"</code>， <code class="language-plaintext highlighter-rouge">"string"</code>，<code class="language-plaintext highlighter-rouge">"boolean"</code> 或 <code class="language-plaintext highlighter-rouge">"symbol"</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p>

<h3 id="instanceof-类型保护">instanceof 类型保护</h3>

<p>如果你已经阅读了 <code class="language-plaintext highlighter-rouge">typeof</code> 类型保护并且对 JavaScript 里的 <code class="language-plaintext highlighter-rouge">instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p>

<p><code class="language-plaintext highlighter-rouge">instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Bird</span> <span class="p">{</span>
  <span class="nx">fly</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">bird fly</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">layEggs</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">bird lay eggs</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Fish</span> <span class="p">{</span>
  <span class="nx">swim</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fish swim</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">layEggs</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fish lay eggs</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getRandomPet</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="p">?</span> <span class="k">new</span> <span class="nx">Bird</span><span class="p">()</span> <span class="p">:</span> <span class="k">new</span> <span class="nx">Fish</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">pet</span> <span class="o">=</span> <span class="nx">getRandomPet</span><span class="p">()</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">pet</span> <span class="k">instanceof</span> <span class="nx">Bird</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">pet</span><span class="p">.</span><span class="nx">fly</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">pet</span> <span class="k">instanceof</span> <span class="nx">Fish</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">pet</span><span class="p">.</span><span class="nx">swim</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="可以为-null-的类型">可以为 null 的类型</h2>

<p>TypeScript 具有两种特殊的类型，<code class="language-plaintext highlighter-rouge">null</code> 和 <code class="language-plaintext highlighter-rouge">undefined</code>，它们分别具有值 <code class="language-plaintext highlighter-rouge">null</code> 和 <code class="language-plaintext highlighter-rouge">undefined</code>。我们在<a href="/chapter2/type">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为 <code class="language-plaintext highlighter-rouge">null</code> 与 <code class="language-plaintext highlighter-rouge">undefined</code> 可以赋值给任何类型。 <code class="language-plaintext highlighter-rouge">null</code> 与 <code class="language-plaintext highlighter-rouge">undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。<code class="language-plaintext highlighter-rouge">null</code>的发明者，Tony Hoare，称它为<a href="https://en.wikipedia.org/wiki/Null_pointer#History">价值亿万美金的错误</a>。</p>

<p><code class="language-plaintext highlighter-rouge">--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code class="language-plaintext highlighter-rouge">null</code> 或 <code class="language-plaintext highlighter-rouge">undefined</code>。 你可以使用联合类型明确的包含它们：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span>
<span class="nx">s</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// 错误, 'null'不能赋值给'string'</span>
<span class="kd">let</span> <span class="nx">sn</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span>
<span class="nx">sn</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// 可以</span>

<span class="nx">sn</span> <span class="o">=</span> <span class="kc">undefined</span> <span class="c1">// error, 'undefined'不能赋值给'string | null'</span>
</code></pre></div></div>

<p>注意，按照 JavaScript 的语义，TypeScript 会把 <code class="language-plaintext highlighter-rouge">null</code> 和 <code class="language-plaintext highlighter-rouge">undefined</code> 区别对待。<code class="language-plaintext highlighter-rouge">string | null</code>，<code class="language-plaintext highlighter-rouge">string | undefined</code> 和 <code class="language-plaintext highlighter-rouge">string | undefined | null</code> 是不同的类型。</p>

<h3 id="可选参数和可选属性">可选参数和可选属性</h3>

<p>使用了 <code class="language-plaintext highlighter-rouge">--strictNullChecks</code>，可选参数会被自动地加上 <code class="language-plaintext highlighter-rouge">| undefined</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">?:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="p">(</span><span class="nx">y</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">)</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span> <span class="c1">// error, 'null' 不能赋值给 'number | undefined'</span>
</code></pre></div></div>

<p>可选属性也会有同样的处理：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">C</span> <span class="p">{</span>
  <span class="nl">a</span><span class="p">:</span> <span class="kr">number</span>
  <span class="nx">b</span><span class="p">?:</span> <span class="kr">number</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">()</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">12</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="kc">undefined</span> <span class="c1">// error, 'undefined' 不能赋值给 'number'</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">13</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="kc">undefined</span> <span class="c1">// ok</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// error, 'null' 不能赋值给 'number | undefined'</span>
</code></pre></div></div>

<h3 id="类型保护和类型断言">类型保护和类型断言</h3>

<p>由于可以为 <code class="language-plaintext highlighter-rouge">null</code> 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 <code class="language-plaintext highlighter-rouge">null</code>。幸运地是这与在 <code class="language-plaintext highlighter-rouge">JavaScript</code> 里写的代码一致：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">sn</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">sn</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">default</span><span class="dl">'</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">sn</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里很明显地去除了 <code class="language-plaintext highlighter-rouge">null</code>，你也可以使用短路运算符：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">sn</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sn</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">default</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果编译器不能够去除 <code class="language-plaintext highlighter-rouge">null</code> 或 <code class="language-plaintext highlighter-rouge">undefined</code>，你可以使用类型断言手动去除。语法是添加 <code class="language-plaintext highlighter-rouge">!</code> 后缀： <code class="language-plaintext highlighter-rouge">identifier!</code> 从 <code class="language-plaintext highlighter-rouge">identifier</code> 的类型里去除了 <code class="language-plaintext highlighter-rouge">null</code> 和 <code class="language-plaintext highlighter-rouge">undefined</code>：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">broken</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">postfix</span><span class="p">(</span><span class="nx">epithet</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">name</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.  the </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">epithet</span> <span class="c1">// error, 'name' 可能为 null</span>
  <span class="p">}</span>
  <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Bob</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">postfix</span><span class="p">(</span><span class="dl">'</span><span class="s1">great</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">fixed</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">postfix</span><span class="p">(</span><span class="nx">epithet</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">name</span><span class="o">!</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.  the </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">epithet</span> <span class="c1">// ok</span>
  <span class="p">}</span>
  <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">Bob</span><span class="dl">'</span>
  <span class="k">return</span> <span class="nx">postfix</span><span class="p">(</span><span class="dl">'</span><span class="s1">great</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">broken</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>

</code></pre></div></div>

<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code class="language-plaintext highlighter-rouge">null</code>（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code class="language-plaintext highlighter-rouge">name</code> 的类型。</p>

<h2 id="字符串字面量类型">字符串字面量类型</h2>

<p>字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Easing</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">ease-in</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">ease-out</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">ease-in-out</span><span class="dl">'</span>

<span class="kd">class</span> <span class="nx">UIElement</span> <span class="p">{</span>
  <span class="nx">animate</span> <span class="p">(</span><span class="nx">dx</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">dy</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">easing</span><span class="p">:</span> <span class="nx">Easing</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">easing</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">ease-in</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">easing</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">ease-out</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">easing</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">ease-in-out</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// error! 不能传入 null 或者 undefined.</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">button</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">UIElement</span><span class="p">()</span>
<span class="nx">button</span><span class="p">.</span><span class="nx">animate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">ease-in</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">button</span><span class="p">.</span><span class="nx">animate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">uneasy</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// error</span>

</code></pre></div></div>

<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Argument of type '"uneasy"' is not assignable to parameter of type '"ease-in" | "ease-out" | "ease-in-out"'
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>那么到这里，我们的 TypeScript 常用语法学习就告一段落了，当然 TypeScript 还有其他的语法我们并没有讲，我们只是讲了 TypeScript 的一些常用语法，你们把这些知识学会已经足以开发一般的应用了。如果你在使用 TypeScript 开发项目中遇到了其他的 TypeScript 语法知识，你可以通过 TypeScript 的<a href="https://www.typescriptlang.org/docs/home.html">官网文档</a>学习。因为学基础最好的方法还是去阅读它的官网文档，敲上面的小例子。其实我们课程的基础知识结构也是大部分参考了官网文档，要记住学习一门技术的基础官网文档永远是最好的第一手资料。</p>

<p>但是 TypeScript 的学习不能仅仅靠看官网文档，你还需要动手实践，在实践中你才能真正掌握 TypeScript。相信很多同学学习到这里已经迫不及待想要大展身手了，那么下面我们就开始把理论转换为实践，一起来用 TypeScript 重构 axios 吧！</p>
