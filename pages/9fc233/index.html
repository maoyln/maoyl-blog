<h1 id="最大子列问题maximum-subarray-problem">最大子列问题（Maximum Subarray Problem）</h1>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">最大子列问题（Maximum Subarray Problem）</code>是一个经典的算法问题，它要求找出一个序列中和最大的连续子序列。这个问题可以用不同的方法解决，包括暴力法、分治法、动态规划等，其中动态规划方法最为高效，时间复杂度为O(n)。</p>
</blockquote>

<p><strong>问题描述</strong>： 给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>

<p><strong>示例</strong>：假设我们有数组<code class="language-plaintext highlighter-rouge">nums = [-2,1,-3,4,-1,2,1,-5,4]</code>，最大子列为<code class="language-plaintext highlighter-rouge">[4,-1,2,1</code>]，其最大和为<code class="language-plaintext highlighter-rouge">6</code>。</p>

<h2 id="解体思路">解体思路</h2>

<p><strong>暴力法</strong>：
<a href="https://github.com/maoyln/data-structure-algorithm/blob/main/week1/practice/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E9%97%AE%E9%A2%98/A%E6%9A%B4%E5%8A%9B%E6%B3%95.js">git地址</a></p>

<p>::: warning 解体思路
我们需要遍历数组的所有可能子列，并计算它们的和，然后找到最大的那个和。
暴力法的时间复杂度是O(n^3)，因为它涉及到三层嵌套循环：外两层循环用来确定子列的起始和结束位置，内层循环用来计算子列的和。
:::</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>

<span class="kd">function</span> <span class="nx">getMaximum</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maximum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">listLength</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">listLength</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">listLength</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">k</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">list</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&gt;</span> <span class="nx">maximum</span><span class="p">)</span> <span class="nx">maximum</span> <span class="o">=</span> <span class="nx">sum</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">maximum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">maximum</span> <span class="o">=</span> <span class="nx">getMaximum</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">maximum</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>这段代码通过三层循环遍历数组的所有可能子列，计算每个子列的和，并不断更新最大和。</li>
  <li>请注意，虽然这种方法可以正确解决问题，但由于其低效的时间复杂度，它不适用于处理大规模数据。</li>
  <li>在实际应用中，推荐使用更高效的算法，如Kadane算法，它的时间复杂度为O(n)。</li>
</ul>

<p><strong>分治法</strong>：<a href="https://github.com/maoyln/data-structure-algorithm/blob/main/week1/practice/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E9%97%AE%E9%A2%98/B%E5%88%86%E6%B2%BB%E6%B3%95.js">git地址</a></p>

<p>::: warning 解体思路
分治法是解决最大子列问题的一种有效方法，其基本思想是将一个大问题分解成小问题逐个击破。对于最大子列问题，可以将数组分成两半，分别求解左半部分和右半部分的最大子列和，以及跨越中点的最大子列和，然后取这三者中的最大值作为整个数组的最大子列和。这种方法的时间复杂度是O(n log n)。
:::</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">maxCrossingSum</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">leftSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 包括中点的左半部分的最大子列和</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">mid</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">left</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&gt;</span> <span class="nx">leftSum</span><span class="p">)</span> <span class="nx">leftSum</span> <span class="o">=</span> <span class="nx">sum</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">rightSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 包括中点的右半部分的最大子列和</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&gt;</span> <span class="nx">rightSum</span><span class="p">)</span> <span class="nx">rightSum</span> <span class="o">=</span> <span class="nx">sum</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 返回跨越中点的最大子列和</span>
  <span class="k">return</span> <span class="nx">leftSum</span> <span class="o">+</span> <span class="nx">rightSum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">maxSubArraySum</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 基本情况</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">==</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">left</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// 找到中点</span>
  <span class="kd">let</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// 返回以下三者中的最大值：</span>
  <span class="c1">// 1. 左半部分的最大子列和</span>
  <span class="c1">// 2. 右半部分的最大子列和</span>
  <span class="c1">// 3. 跨越中点的最大子列和</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span>
    <span class="nx">maxSubArraySum</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="p">),</span>
    <span class="nx">maxSubArraySum</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">right</span><span class="p">),</span>
    <span class="nx">maxCrossingSum</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 示例</span>
<span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">maxSubArraySum</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// 输出最大子列和，例如上述数组的最大子列和为6</span>
</code></pre></div></div>

<p>这段代码首先定义了maxCrossingSum函数，用于计算跨越中点的最大子列和。然后，maxSubArraySum函数通过递归地将数组分成更小的部分，分别求解左半部分和右半部分的最大子列和，以及跨越中点的最大子列和，最后取这三者中的最大值作为结果。这种分而治之的策略使得问题得以有效解决。</p>

<p><strong>在线处理【动态规划（Kadane算法）】</strong>：<a href="https://github.com/maoyln/data-structure-algorithm/blob/main/week1/practice/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E9%97%AE%E9%A2%98/C%E5%9C%A8%E7%BA%BF%E5%A4%84%E7%90%86.js">git地址</a>
::: tip 解体思路
动态规划是解决最大子列问题的一种高效方法，其中Kadane算法是最著名的实现之一。
Kadane算法的核心思想是遍历数组，同时计算当前最大子列和，如果当前最大子列和变成负数，则从下一个元素重新开始计算。这种方法的时间复杂度是O(n)，是解决这个问题的最快方法之一。
:::</p>

<p><strong>基础方法</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">function</span> <span class="nx">getMaximum</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maximum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&gt;</span> <span class="nx">maximum</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">maximum</span> <span class="o">=</span> <span class="nx">sum</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">maximum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">maximum</span> <span class="o">=</span> <span class="nx">getMaximum</span><span class="p">(</span><span class="nx">list</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">maximum</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>也可以用下main方法实现</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getMaximum_1</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maximum</span> <span class="o">=</span> <span class="nx">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="nx">maximum</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">maximum</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">maximum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">maximum_1</span> <span class="o">=</span> <span class="nx">getMaximum_1</span><span class="p">(</span><span class="nx">list</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">maximum_1</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="kadane算法优点">Kadane算法优点：</h2>

<ul>
  <li><strong>时间效率高</strong>：Kadane算法的时间复杂度为O(n)，其中n是数组的长度。这意味着算法只需要遍历数组一次就可以找到最大子数组和，这是解决这类问题的最快方法之一。</li>
  <li><strong>空间效率高</strong>：Kadane算法只需要O(1)的额外空间，因为它在遍历数组的过程中只维护了几个变量来存储中间计算结果，如当前元素之前的最大子数组和和全局最大子数组和。</li>
  <li><strong>实现简单</strong>：与其他算法相比，Kadane算法的实现相对简单直观。它避免了复杂的数据结构和算法技巧，使得即使是对动态规划不太熟悉的开发者也能轻松掌握。</li>
  <li><strong>广泛适用性</strong>：尽管Kadane算法最初是为解决最大子数组和问题设计的，但它的思想可以被扩展应用于解决其他类型的动态规划问题，比如寻找数组中的最大子序列乘积等。</li>
  <li><strong>优雅的处理负数情况</strong>：Kadane算法能够优雅地处理全部为负数的数组。在这种情况下，它会返回单个最大负数，这在数学上是正确的处理方式，因为任何包含多个负数的子数组和都会更小。</li>
</ul>

<h2 id="拓展-在线处理拓展git地址">拓展 <a href="https://github.com/maoyln/data-structure-algorithm/blob/main/week1/practice/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E9%97%AE%E9%A2%98/D%E5%9C%A8%E7%BA%BF%E5%A4%84%E7%90%86%E6%8B%93%E5%B1%95.js">在线处理拓展git地址</a></h2>

<blockquote>
  <p>获取最大子列和、最大子列的第一个数字和最大子列最后一个数字、最大子列</p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">13</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">// 输出最大子列和、最大子列开始和结束的数字、最大子列</span>
<span class="kd">function</span> <span class="nx">getMaximum</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maximum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">allList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">allList</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&gt;</span> <span class="nx">maximum</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">maximum</span> <span class="o">=</span> <span class="nx">sum</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">allList</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">allList</span><span class="p">,</span> <span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">const</span> <span class="nx">startEndList</span> <span class="o">=</span> <span class="p">[</span><span class="nx">allList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">allList</span><span class="p">[</span><span class="nx">allList</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

  <span class="c1">// 输出</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">maximum</span><span class="p">,</span> <span class="nx">startEndList</span><span class="p">,</span> <span class="nx">allList</span><span class="p">};</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getMaximum</span><span class="p">(</span><span class="nx">list</span><span class="p">));</span>
<span class="c1">// 结果：</span>
<span class="c1">// {</span>
<span class="c1">//  maximum: 45,</span>
<span class="c1">//  startEndList: [ 11, 2 ],</span>
<span class="c1">//  allList: [</span>
<span class="c1">//     11, -4, 13,  -5, -2, 12,</span>
<span class="c1">//      3,  4,  5, -12,  3, 12,</span>
<span class="c1">//    -13, 12,  4,   2</span>
<span class="c1">//  ]</span>
<span class="c1">//}</span>
</code></pre></div></div>

<blockquote>
  <p>获取最大子列和、最大子列的第一个数字和最大子列最后一个数字<code class="language-plaintext highlighter-rouge">该方法存在问题</code></p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 输出最大子列和，最大子列开始的数字和最大子列结束的数字</span>
<span class="kd">function</span> <span class="nx">findMaxSubsequence</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">tempSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">tempStart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">end</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kd">let</span> <span class="nx">allNegative</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 假设所有数字都是负数</span>

  <span class="c1">// 遍历数组，寻找最大子序列和</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">tempSum</span> <span class="o">+=</span> <span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

    <span class="c1">// 检查是否所有数字都是负数</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">allNegative</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">tempSum</span> <span class="o">&gt;</span> <span class="nx">maxSum</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">maxSum</span> <span class="o">=</span> <span class="nx">tempSum</span><span class="p">;</span>
      <span class="nx">start</span> <span class="o">=</span> <span class="nx">tempStart</span><span class="p">;</span>
      <span class="nx">end</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">tempSum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">tempSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">tempStart</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 如果所有数字都是负数，最大子序列和为0，返回整个序列的第一个和最后一个数字</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">allNegative</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">end</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">[</span><span class="nx">maxSum</span><span class="p">,</span> <span class="nx">list</span><span class="p">[</span><span class="nx">start</span><span class="p">],</span> <span class="nx">list</span><span class="p">[</span><span class="nx">end</span><span class="p">]];</span>
<span class="p">}</span>

<span class="c1">// 测试用例</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">findMaxSubsequence</span><span class="p">(</span><span class="nx">list</span><span class="p">));</span>
<span class="c1">// 结果：[ 45, 11, 2 ]</span>
</code></pre></div></div>

<p>```tip 漏洞补充 【如果数据全是负数和0，且包含0】
正确的返回结果应该是： [0, 0, 0]
下面是代码</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```javascript
function isAllNonPositiveAndContainsZero(arr) {
  let containsZero = false;
  // 遍历数组中的每个元素
  for (let i = 0; i &lt; arr.length; i++) {
    // 如果找到一个大于0的元素，返回false
    if (arr[i] &gt; 0) {
      return false;
    }
    // 检查是否至少有一个元素是0
    if (arr[i] === 0) {
      containsZero = true;
    }
  }
  // 确保数组至少包含一个0
  return containsZero;
}

function getMaximum(list) {
  let maxSum = 0;
  let tempSum = 0;
  let start = 0;
  let tempStart = 0;
  let end = list.length - 1;

  let allNegative = true; // 假设所有数字都是负数
  if (isAllNonPositiveAndContainsZero(list)) {
    return [0, 0, 0];
  }

  // 遍历数组，寻找最大子序列和
  for (let i = 0; i &lt; list.length; i++) {
    tempSum += list[i];

    // 检查是否所有数字都是负数
    if (list[i] &gt; 0) {
      allNegative = false;
    }

    if (tempSum &gt; maxSum) {
      maxSum = tempSum;
      start = tempStart;
      end = i;
    } else if (tempSum &lt; 0) {
      tempSum = 0;
      tempStart = i + 1;
    }
  }

  // 如果所有数字都是负数，最大子序列和为0，返回整个序列的第一个和最后一个数字
  if (allNegative) {
    maxSum = 0;
    start = 0;
    end = list.length - 1;
  }

  return maxSum, list[start], list[end];
}
</code></pre></div></div>
