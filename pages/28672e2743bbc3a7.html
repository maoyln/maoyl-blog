<h1 id="基础类型">基础类型</h1>

<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>

<h2 id="布尔值">布尔值</h2>

<p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code class="language-plaintext highlighter-rouge">boolean</code>（其它语言中也一样）。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">isDone</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span>
</code></pre></div></div>

<h2 id="数字">数字</h2>

<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">decLiteral</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">20</span>
<span class="kd">let</span> <span class="nx">hexLiteral</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mh">0x14</span>
<span class="kd">let</span> <span class="nx">binaryLiteral</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mb">0b10100</span>
<span class="kd">let</span> <span class="nx">octalLiteral</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mo">0o24</span>
</code></pre></div></div>

<h2 id="字符串">字符串</h2>

<p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code class="language-plaintext highlighter-rouge">string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code class="language-plaintext highlighter-rouge">"</code>）或单引号（<code class="language-plaintext highlighter-rouge">'</code>）表示字符串。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">bob</span><span class="dl">'</span>
<span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">smith</span><span class="dl">'</span>
</code></pre></div></div>

<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <code class="language-plaintext highlighter-rouge">`</code>），并且以 <code class="language-plaintext highlighter-rouge">${ expr }</code> 这种形式嵌入表达式</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="s2">`Yee`</span>
<span class="kd">let</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">37</span>
<span class="kd">let</span> <span class="nx">sentence</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="s2">`Hello, my name is </span><span class="p">${</span> <span class="nx">name</span> <span class="p">}</span><span class="s2">.

I'll be </span><span class="p">${</span> <span class="nx">age</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span><span class="s2"> years old next month.`</span>
</code></pre></div></div>

<p>这与下面定义 <code class="language-plaintext highlighter-rouge">sentence</code> 的方式效果相同：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">sentence</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello, my name is </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.</span><span class="se">\n\n</span><span class="dl">'</span> <span class="o">+</span>
    <span class="dl">'</span><span class="s1">I</span><span class="se">\'</span><span class="s1">ll be </span><span class="dl">'</span> <span class="o">+</span> <span class="p">(</span><span class="nx">age</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> years old next month.</span><span class="dl">'</span>
</code></pre></div></div>

<h2 id="数组">数组</h2>

<p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code class="language-plaintext highlighter-rouge">[]</code>，表示由此类型元素组成的一个数组：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">list</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<p>第二种方式是使用数组泛型，<code class="language-plaintext highlighter-rouge">Array&lt;元素类型&gt;</code>：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">list</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="元组-tuple">元组 Tuple</h2>

<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code class="language-plaintext highlighter-rouge">string</code> 和 <code class="language-plaintext highlighter-rouge">number</code> 类型的元组。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span><span class="p">:</span> <span class="p">[</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span>
<span class="nx">x</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span> <span class="c1">// OK</span>
<span class="nx">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">]</span> <span class="c1">// Error</span>
</code></pre></div></div>

<p>当访问一个已知索引的元素，会得到正确的类型：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">// OK</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">// Error, 'number' 不存在 'substr' 方法</span>
</code></pre></div></div>

<p>当访问一个越界的元素，会使用联合类型替代：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">world</span><span class="dl">'</span> <span class="c1">// OK, 字符串可以赋值给(string | number)类型</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="nx">toString</span><span class="p">())</span> <span class="c1">// OK, 'string' 和 'number' 都有 toString</span>

<span class="nx">x</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span> <span class="c1">// Error, 布尔不是(string | number)类型</span>
</code></pre></div></div>

<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>

<p><strong>注意</strong>：自从 TyeScript 3.1 版本之后，访问越界元素会报错，我们不应该再使用该特性。</p>

<h2 id="枚举">枚举</h2>

<p><code class="language-plaintext highlighter-rouge">enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Color</span> <span class="p">{</span><span class="nx">Red</span><span class="p">,</span> <span class="nx">Green</span><span class="p">,</span> <span class="nx">Blue</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">c</span><span class="p">:</span> <span class="nx">Color</span> <span class="o">=</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Green</span>
</code></pre></div></div>

<p>默认情况下，从 <code class="language-plaintext highlighter-rouge">0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code class="language-plaintext highlighter-rouge">1</code> 开始编号：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Color</span> <span class="p">{</span><span class="nx">Red</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Green</span><span class="p">,</span> <span class="nx">Blue</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">c</span><span class="p">:</span> <span class="nx">Color</span> <span class="o">=</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Green</span>
</code></pre></div></div>

<p>或者，全部都采用手动赋值：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Color</span> <span class="p">{</span><span class="nx">Red</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Green</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">Blue</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">c</span><span class="p">:</span> <span class="nx">Color</span> <span class="o">=</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Green</span>
</code></pre></div></div>

<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Color</span> <span class="p">{</span><span class="nx">Red</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Green</span><span class="p">,</span> <span class="nx">Blue</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">colorName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="nx">Color</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colorName</span><span class="p">)</span>  <span class="c1">// 显示'Green'因为上面代码里它的值是2</span>
</code></pre></div></div>

<h2 id="any">any</h2>

<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code class="language-plaintext highlighter-rouge">any</code> 类型来标记这些变量：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">notSure</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nx">notSure</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">maybe a string instead</span><span class="dl">'</span>
<span class="nx">notSure</span> <span class="o">=</span> <span class="kc">false</span> <span class="c1">// 也可以是个 boolean</span>
</code></pre></div></div>

<p>在对现有代码进行改写的时候，<code class="language-plaintext highlighter-rouge">any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code class="language-plaintext highlighter-rouge">any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">list</span><span class="p">:</span> <span class="kr">any</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="dl">'</span><span class="s1">free</span><span class="dl">'</span><span class="p">]</span>

<span class="nx">list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
</code></pre></div></div>

<h2 id="void">void</h2>

<p>某种程度上来说，<code class="language-plaintext highlighter-rouge">void</code> 类型像是与 <code class="language-plaintext highlighter-rouge">any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code class="language-plaintext highlighter-rouge">void</code>：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">warnUser</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">This is my warning message</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>

<p>声明一个 <code class="language-plaintext highlighter-rouge">void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code>：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">unusable</span><span class="p">:</span> <span class="k">void</span> <span class="o">=</span> <span class="kc">undefined</span>
</code></pre></div></div>

<h2 id="null-和-undefined">null 和 undefined</h2>

<p>TypeScript 里，<code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code> 两者各自有自己的类型分别叫做 <code class="language-plaintext highlighter-rouge">undefined</code> 和 <code class="language-plaintext highlighter-rouge">null</code>。 和 <code class="language-plaintext highlighter-rouge">void</code> 相似，它们的本身的类型用处不是很大：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">u</span><span class="p">:</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="kc">undefined</span>
<span class="kd">let</span> <span class="nx">n</span><span class="p">:</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span>
</code></pre></div></div>

<p>默认情况下 <code class="language-plaintext highlighter-rouge">null</code> 和 <code class="language-plaintext highlighter-rouge">undefined</code> 是所有类型的子类型。 就是说你可以把 <code class="language-plaintext highlighter-rouge">null</code> 和 <code class="language-plaintext highlighter-rouge">undefined</code> 赋值给 <code class="language-plaintext highlighter-rouge">number</code> 类型的变量。</p>

<p>然而，当你指定了 <code class="language-plaintext highlighter-rouge">--strictNullChecks</code> 标记，<code class="language-plaintext highlighter-rouge">null</code> 和 <code class="language-plaintext highlighter-rouge">undefined</code> 只能赋值给 <code class="language-plaintext highlighter-rouge">void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code class="language-plaintext highlighter-rouge">string</code> 或 <code class="language-plaintext highlighter-rouge">null</code> 或 <code class="language-plaintext highlighter-rouge">undefined</code>，你可以使用联合类型 <code class="language-plaintext highlighter-rouge">string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>

<h2 id="never">never</h2>

<p><code class="language-plaintext highlighter-rouge">never</code> 类型表示的是那些永不存在的值的类型。 例如， <code class="language-plaintext highlighter-rouge">never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code class="language-plaintext highlighter-rouge">never</code> 类型，当它们被永不为真的类型保护所约束时。</p>

<p><code class="language-plaintext highlighter-rouge">never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code class="language-plaintext highlighter-rouge">never</code> 的子类型或可以赋值给<code class="language-plaintext highlighter-rouge">never</code> 类型（除了 <code class="language-plaintext highlighter-rouge">never</code> 本身之外）。 即使 <code class="language-plaintext highlighter-rouge">any</code> 也不可以赋值给 <code class="language-plaintext highlighter-rouge">never</code>。</p>

<p>下面是一些返回 <code class="language-plaintext highlighter-rouge">never</code> 类型的函数：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 返回never的函数必须存在无法达到的终点</span>
<span class="kd">function</span> <span class="nx">error</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">never</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 推断的返回值类型为never</span>
<span class="kd">function</span> <span class="nx">fail</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Something failed</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 返回never的函数必须存在无法达到的终点</span>
<span class="kd">function</span> <span class="nx">infiniteLoop</span><span class="p">():</span> <span class="nx">never</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="object">object</h2>

<p><code class="language-plaintext highlighter-rouge">object</code> 表示非原始类型，也就是除 <code class="language-plaintext highlighter-rouge">number</code>，<code class="language-plaintext highlighter-rouge">string</code>，<code class="language-plaintext highlighter-rouge">boolean</code>，<code class="language-plaintext highlighter-rouge">symbol</code>，<code class="language-plaintext highlighter-rouge">null</code>或<code class="language-plaintext highlighter-rouge">undefined</code> 之外的类型。</p>

<p>使用 <code class="language-plaintext highlighter-rouge">object</code> 类型，就可以更好的表示像 <code class="language-plaintext highlighter-rouge">Object.create</code> 这样的 <code class="language-plaintext highlighter-rouge">API</code>。例如：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">create</span><span class="p">(</span><span class="nx">o</span><span class="p">:</span> <span class="nx">object</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="k">void</span>

<span class="nx">create</span><span class="p">({</span> <span class="na">prop</span><span class="p">:</span> <span class="mi">0</span> <span class="p">})</span> <span class="c1">// OK</span>
<span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// OK</span>

<span class="nx">create</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="c1">// Error</span>
<span class="nx">create</span><span class="p">(</span><span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// Error</span>
<span class="nx">create</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// Error</span>
<span class="nx">create</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// Error</span>
</code></pre></div></div>

<h2 id="类型断言">类型断言</h2>

<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>

<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>

<p>类型断言有两种形式。 其一是“尖括号”语法：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">someValue</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">this is a string</span><span class="dl">'</span>

<span class="kd">let</span> <span class="nx">strLength</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="nx">someValue</span><span class="p">).</span><span class="nx">length</span>
</code></pre></div></div>

<p>另一个为 <code class="language-plaintext highlighter-rouge">as</code> 语法：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">someValue</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">this is a string</span><span class="dl">'</span>

<span class="kd">let</span> <span class="nx">strLength</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="p">(</span><span class="nx">someValue</span> <span class="k">as</span> <span class="kr">string</span><span class="p">).</span><span class="nx">length</span>
</code></pre></div></div>

<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code class="language-plaintext highlighter-rouge">as</code> 语法断言是被允许的。</p>
